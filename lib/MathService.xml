<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MathService</name>
    </assembly>
    <members>
        <member name="T:MathService.BigInteger">
            <summary> Целочисленная арифметика с большими числами  </summary>
        </member>
        <member name="F:MathService.BigInteger.c_MaxLength">
            <summary>Максимальная длина числа в байтах</summary>
        </member>
        <member name="F:MathService.BigInteger.PrimesBelow2000">
            <summary>Простые числа до 2000</summary>
        </member>
        <member name="T:MathService.CommandProcessor.Argument">
            <summary>Аргумент команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Name">
            <summary>Имя аргумента</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Values">
            <summary>Массив значений аргумента</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Value">
            <summary>Значение аргумента</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Count">
            <summary>Количество значений аргумента</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Item(System.Int32)">
            <summary>Доступ к значениям аргумента по номеру</summary>
            <param name="i">Номер значения</param>
            <returns>Значение аргумента с указанным номером</returns>
        </member>
        <member name="M:MathService.CommandProcessor.Argument.#ctor(System.String,System.Char)">
            <summary>Аргумент команды</summary>
            <param name="ArgStr">Строковое описание аргумента</param>
            <param name="ValueSplitter">Разделитель имени аргумента и значения</param>
        </member>
        <member name="M:MathService.CommandProcessor.Argument.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление аргумента</returns>
        </member>
        <member name="T:MathService.CommandProcessor.Command">
            <summary>Команда</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Command.Name">
            <summary>Имя команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Command.Parameter">
            <summary>Параметр команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Command.Argument">
            <summary>Массив аргументов команды</summary>
        </member>
        <member name="M:MathService.CommandProcessor.Command.#ctor(System.String,System.Char,System.Char,System.Char)">
            <summary>Команда</summary>
            <param name="CommandStr">Строковое представление команды</param>
            <param name="ParameterSplitter">Разделитель имени и параметра команды</param>
            <param name="ArgSplitter">Разделитель аргументов команды</param>
            <param name="ValueSplitter">Разделитель имени аргумента и его значения</param>
        </member>
        <member name="M:MathService.CommandProcessor.Command.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление команды</returns>
        </member>
        <member name="T:MathService.CommandProcessor.CommandEventArgs">
            <summary>Аргумент события обработки команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandEventArgs.Command">
            <summary>Обрабатываемая команда</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandEventArgs.Commands">
            <summary>Перечень команд сессии</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandEventArgs.Index">
            <summary>Индекс команды в перечне команд сессии</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandEventArgs.Handled">
            <summary>Признак того, что команда обработана</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandEventArgs.ToString">
            <summary>Строковое представление</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathService.CommandProcessor.CommandHandlersList">
            <summary>Список обработчиков команды</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandHandlersList.op_Addition(MathService.CommandProcessor.CommandHandlersList,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[]})">
            <summary>Оператор добалвения команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Добавляемый обработчик команды</param>
            <returns>Список с добавленным обработчиком команды</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandHandlersList.op_Subtraction(MathService.CommandProcessor.CommandHandlersList,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[]})">
            <summary>Оператор удаления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandArgHandlersList.op_Addition(MathService.CommandProcessor.CommandArgHandlersList,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[],MathService.CommandProcessor.Argument})">
            <summary>Оператор добалвения команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Добавляемый обработчик команды</param>
            <returns>Список с добавленным обработчиком команды</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandArgHandlersList.op_Subtraction(MathService.CommandProcessor.CommandArgHandlersList,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[],MathService.CommandProcessor.Argument})">
            <summary>Оператор удаления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="T:MathService.CommandProcessor.CommandLineProcessor">
            <summary>Командный процессор</summary>
        </member>
        <member name="E:MathService.CommandProcessor.CommandLineProcessor.CommandProcess">
            <summary>Событие обработки команды</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.OnCommandProcess(MathService.CommandProcessor.CommandEventArgs)">
            <summary>Обработка команды</summary>
            <param name="Arg">Аргумент, содержащий сведенья о команде</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.OnCommandProcess(MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[])">
            <summary>Обработка команды</summary>
            <param name="command">Обрабатываемая команда</param>
            <param name="index">Индекс команды в массиве команд сессии</param>
            <param name="commands">Массив команд сессии</param>
        </member>
        <member name="E:MathService.CommandProcessor.CommandLineProcessor.UnhandledCommand">
            <summary>Событие появления необработанной команды</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.OnUnhandledCommand(MathService.CommandProcessor.CommandEventArgs)">
            <summary>Генерация события обнаружения необработанной команды</summary>
            <param name="Arg">Аргумент события, содержащий сведенья о команде</param>
        </member>
        <member name="F:MathService.CommandProcessor.CommandLineProcessor.f_CommandHandlers">
            <summary>Словарь списков обработчиков команд</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.CommandSplitter">
            <summary>Разделитель команд в строке</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.CommandParameterSplitter">
            <summary>Разделитель имени команды и её параметра</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.ArgSplitter">
            <summary>Разделитель аргументов команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.ValueSplitter">
            <summary>Разделитель имени аргумента и его значения</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.Item(System.String)">
            <summary>Доступ к списку обработчиков команды по её имени</summary>
            <param name="CommandName">Имя команды</param>
            <returns>Список обработчиков команды</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.#ctor(System.Char,System.Char,System.Char,System.Char)">
            <summary>Командный процессор</summary>
            <param name="CommandSplitter">Разделитель команд в строке</param>
            <param name="CommandParameterSplitter">Разделитель имени команды и её параметра</param>
            <param name="ArgSplitter">Разделитель аргументов</param>
            <param name="ValueSplitter">Разделитель имени аргумента и его значения</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.Process(System.String[])">
            <summary>Обработать команду</summary>
            <param name="CommandLine">Командная строка</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.AddCommandHandler(System.String,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[]})">
            <summary>Добавить обработчик команды</summary>
            <param name="CommandName">Имя команды</param>
            <param name="CommandHandler">ДОбавляемый обработчик команды</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.RemoveCommandHandler(System.String,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[]})">
            <summary>Удалить обработчик команды</summary>
            <param name="CommandName">Имя команды</param>
            <param name="CommandHandler">Удаляемый обработчик команды</param>
            <returns>Истина, если удалось обработчик команды удалить</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.ClaerCommandHandlers(System.String)">
            <summary>Очистить список обработчиков команды</summary>
            <param name="CommandName">Имя команды</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.ClaerCommandHandlers">
            <summary>Очистить все обработчики команд</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.GetRegistredCommands">
            <summary>Получить перечисление имён команд с зарегистрированными обработчиками</summary>
            <returns>Перечисление имён команд, имеющих свои обработчики</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.IsRegistredCommand(System.String)">
            <summary>Проверка - имеет ли команда обработчики</summary>
            <param name="CommandName">Проверяемая команда</param>
            <returns>Истина, если указаны обработчики команды</returns>
        </member>
        <member name="T:MathService.CommandProcessor.TestCommandLineProcessor">
            <summary>Пример использования класса команданого процессора</summary>
        </member>
        <member name="P:MathService.CommandProcessor.TestCommandLineProcessor.Work">
            <summary>Флаг обработки запросов пользователя</summary>
        </member>
        <member name="P:MathService.CommandProcessor.TestCommandLineProcessor.Prompt">
            <summary>Приглашение командной строки</summary>
        </member>
        <member name="M:MathService.CommandProcessor.TestCommandLineProcessor.Test">
            <summary>Точка входа в пример</summary>
        </member>
        <member name="M:MathService.CommandProcessor.TestCommandLineProcessor.UnknownCommandInformator(System.Object,MathService.CommandProcessor.CommandEventArgs)">
            <summary>Обработчик необработанных команд</summary>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент, содержащий информацию о необработанной команде</param>
        </member>
        <member name="M:MathService.CommandProcessor.TestCommandLineProcessor.ExecuteCommand(System.Object,MathService.CommandProcessor.CommandEventArgs)">
            <summary>Обработчик команды</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргумент, содержащий информацию о команде</param>
        </member>
        <member name="M:MathService.CommandProcessor.TestCommandLineProcessor.SetArgument(MathService.CommandProcessor.Argument)">
            <summary>Метод установки значения команды Set</summary>
            <param name="SetArg">Аргумент команды Set</param>
        </member>
        <member name="T:MathService.Data.PropertyLink`2">
            <summary>Связь между свойствами</summary>
            <typeparam name="TSource">Тип объекта-источника данных</typeparam>
            <typeparam name="TDestination">Тип объекта-приёмника данных</typeparam>
        </member>
        <member name="F:MathService.Data.PropertyLink`2.f_Source">
            <summary>
            Источник данных
            </summary>
        </member>
        <member name="F:MathService.Data.PropertyLink`2.f_Destination">
            <summary>
            Приёмник данных
            </summary>
        </member>
        <member name="F:MathService.Data.PropertyLink`2.f_SourcePropertyDescriptor">
            <summary>
            Дескриптор свойства источника данных
            </summary>
        </member>
        <member name="F:MathService.Data.PropertyLink`2.f_DestinationPropertyDescriptor">
            <summary>
            Дескриптор свойства приёмника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.Source">
            <summary>
            Источник данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.Destination">
            <summary>
            Приёмник данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.SourceProperty">
            <summary>
            Дескриптор свойства источника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.DestinationProperty">
            <summary>
            Дескриптор свйоства примника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.SourceType">
            <summary>
            Источник данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.DestinationType">
            <summary>
            Приёмник данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.SourcePropertyType">
            <summary>
            Тип свйоства источника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.DestinationPropertyType">
            <summary>
            Тип свойства приёмника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.Enable">
            <summary>
            Активатор связи
            </summary>
        </member>
        <member name="M:MathService.Data.PropertyLink`2.#ctor(`0,System.String,`1,System.String,System.Boolean)">
            <summary>
            Новая связь между свойством источника и приёмника данных
            </summary>
            <param name="Source">Источник данных</param>
            <param name="SourcePropertyName">Имя свойства источника данных</param>
            <param name="Destination">Приёмник данных</param>
            <param name="DestinationPropertyName">Имя свойства приёмника данных</param>
            <param name="Enable">Признак активности связи (по умолчанию = true)</param>
        </member>
        <member name="M:MathService.Data.PropertyLink`2.SourcePropertyChanged(System.Object,System.EventArgs)">
            <summary>
            Обработчик события изменения свойства источника данных
            </summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="T:MathService.DifferencialEquations.Numerical.ArgumentFunction">
            <summary>Функция определения аргумента</summary>
            <param name="t">Параметр</param>
            <returns>Вектор аргумента уравнения</returns>
        </member>
        <member name="T:MathService.DifferencialEquations.Numerical.Eyler">
            <summary>
            Метод Рунге-Кутты
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.Eyler.N">
            <summary>
            Размерность системы
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.Eyler.Y">
            <summary>
            Искомые решения
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.Eyler.t">
            <summary>
            Текущее время
            </summary>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.Eyler.#ctor(System.Int32,MathService.DifferencialEquations.Numerical.DifferencialEquationsSystem,MathService.DifferencialEquations.Numerical.ArgumentFunction)">
            <summary>
            Метод Рунге-Кутты
            </summary>
            <param name="N">Размерность</param>
            <param name="System">Решаемая система</param>
            <param name="X">Производящая функция аргумента</param>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.Eyler.Initialize(System.Double,System.Double[])">
            <summary>
            Начальные условия
            </summary>
            <param name="t0">Начальное время</param>
            <param name="Y0">Начальные условия</param>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.Eyler.NextStep(System.Double)">
            <summary>
            Рассчёт решения
            </summary>
            <param name="dt">Шаг</param>
        </member>
        <member name="T:MathService.DifferencialEquations.Numerical.DifferencialEquationsSystem">
            <summary> Система дифференциальных уравнений</summary>
            <param name="X">Аргумент</param>
            <param name="Y">Значения функции</param>
            <returns>Значения производных</returns>
        </member>
        <member name="T:MathService.DifferencialEquations.Numerical.RungeKutta">
            <summary>
            Метод Рунге-Кутты
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.RungeKutta.N">
            <summary>
            Размерность системы
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.RungeKutta.Y">
            <summary>
            Искомые решения
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.RungeKutta.t">
            <summary>
            Текущее время
            </summary>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.RungeKutta.#ctor(System.Int32,MathService.DifferencialEquations.Numerical.DifferencialEquationsSystem,MathService.DifferencialEquations.Numerical.ArgumentFunction)">
            <summary>
            Метод Рунге-Кутты
            </summary>
            <param name="N">Размерность</param>
            <param name="System">Решаемая система</param>
            <param name="X">Производящая функция аргумента</param>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.RungeKutta.Initialize(System.Double,System.Double[])">
            <summary>
            Начальные условия
            </summary>
            <param name="t0">Начальное время</param>
            <param name="Y0">Начальные условия</param>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.RungeKutta.NextStep(System.Double)">
            <summary>
            Рассчёт решения
            </summary>
            <param name="dt">Шаг</param>
        </member>
        <member name="T:MathService.DSP.DigitalFilter">
            <summary>Цифровой фильтр</summary>
        </member>
        <member name="F:MathService.DSP.DigitalFilter.f_DelayLine">
            <summary>Встроенная линия задержки</summary>
        </member>
        <member name="P:MathService.DSP.DigitalFilter.Order">
            <summary>Порядок фильтра</summary>        
        </member>
        <member name="M:MathService.DSP.DigitalFilter.Initialize">
            <summary>Инициализация начального состояния фильтра</summary>
        </member>
        <member name="M:MathService.DSP.DigitalFilter.Initialize(System.Int32)">
            <summary>Инициализация фильтра с изменением порядка</summary>
            <param name="Order">Порядок фильтра</param>
        </member>
        <member name="M:MathService.DSP.DigitalFilter.ProcessSignal(System.Double[])">
            <summary>Обработка сигнала</summary>
            <param name="x">Входное воздействие в виде отсчётов сигнала</param>
            <returns>Массив отсчётов отклика фильтра</returns>        
        </member>
        <member name="M:MathService.DSP.DigitalFilter.ProcessSignal(MathService.DSP.Signals.DigitalSignal)">
            <summary>обработка входного воздействия в виде цифрового сигнала</summary>
            <param name="s">Входное воздействия в виде цифрового сигнала</param>
            <returns>Отклик фильтра в виде цифрового сигнала</returns>
        </member>
        <member name="M:MathService.DSP.DigitalFilter.GetImpulseResponse(System.Double,System.Double)">
            <summary>Получить импульсную характеристику фильтра</summary>
            <param name="dt">Период дискретизации сигнала</param>
            <param name="Length">Длительность сигнала</param>
            <returns>Импульсная характеристика фильтра</returns>
        </member>
        <member name="T:MathService.DSP.DigitalLowPassRCFilter">
            <summary>Цифровой фильтр нижних частот (RC-цепочка)</summary>
        </member>
        <member name="M:MathService.DSP.DigitalLowPassRCFilter.GetA(System.Double,System.Double)">
             <summary>Получить коэффициенты полинома знаменателя передаточной функции цифрового фильтра</summary>
            <param name="f0">Частота среза</param>
            <param name="dt">Частота дискретизации</param>
             <returns>Коэффициенты полинома a0 + a1 z^-1</returns>
        </member>
        <member name="M:MathService.DSP.DigitalLowPassRCFilter.GetB(System.Double,System.Double)">
             <summary>Получить коэффициенты полинома числителя передаточной функции цифрового фильтра</summary>
            <param name="f0">Частота среза</param>
            <param name="dt">Частота дискретизации</param>
             <returns>Коэффициенты полинома b0 + b1 z^-1</returns>
        </member>
        <member name="F:MathService.DSP.DigitalLowPassRCFilter.f_f0">
            <summary>Частота среза</summary>
        </member>
        <member name="F:MathService.DSP.DigitalLowPassRCFilter.f_dt">
            <summary>Период дискретизации</summary>
        </member>
        <member name="P:MathService.DSP.DigitalLowPassRCFilter.f0">
            <summary>Частота среза</summary>
        </member>
        <member name="P:MathService.DSP.DigitalLowPassRCFilter.dt">
            <summary>Период дискретизации</summary>
        </member>
        <member name="M:MathService.DSP.DigitalLowPassRCFilter.#ctor(System.Double,System.Double)">
            <summary>Цифровой фильтр нижних частот (RC-цепочка)</summary>
            <param name="f0">Частота среза</param>
            <param name="dt">Частота дискретизации</param>
        </member>
        <member name="M:MathService.DSP.DigitalLowPassRCFilter.Initialize(System.Double,System.Double)">
            <summary>Инициализация фильтра</summary>
            <param name="f0">Частота среза</param>
            <param name="dt">Частота дискретизации</param>
        </member>
        <member name="M:MathService.DSP.Fourier.fft.FFT(MathService.Complex[])">
            <summary>
            Быстрое комплексное одномерное преобразование Фурье
            </summary>
            <param name="x">Вектор комплексных значений, преобразуемый в спектр</param>
            <remarks>
            Размер массива N может быть произвольным числом (составным или простым). 
            Составной N будут обработаны с использованием вариативного алгоритма Кули-Тьюки с кешированием.
            Массивы, размер которых соответствует малому простому числу преобразуются с помощью жестко сода
            (по аналогии с кодом FFTW, но без оптимизации низкого уровня), большое простое число элементов 
            обрабатывается с помощью алгоритма Блустейна.
            
            Быстрые преобразования для гладких N (только простые множители 2, 3, 5), самый быстрый для степеней 2. 
            При N имеющих простые множители большие, чем эти, но порядка меньше, чем N, вычисления 
            будут примерно в 4 раза медленнее, чем для близких высоко составных N. 
            Когда N является простым, скорость будет в 6 раз меньше.
            
            Алгоритмическая сложность O(N*logN) для любых N
            </remarks>
        </member>
        <member name="M:MathService.DSP.Fourier.fft.FFT_Complex_Inverse(MathService.Complex[])">
            <summary>
            Быстрое обратное комплексное одномерное преобразование Фурье
            </summary>
            <param name="y">Массив значений спектра</param>
        </member>
        <member name="M:MathService.DSP.Fourier.fft.FFT(System.Double[])">
            <summary>
            Быстрое одномерное вещественное преобразование Фурье
            </summary>
            <param name="x">Массив входных значений</param>
            <value>Массив комплексных значений спектра</value>
        </member>
        <member name="T:MathService.DSP.Fourier.DoubleArray_FT">
            <summary>
            
            </summary>
        </member>
        <member name="T:MathService.DSP.Fourier.FFT">
            <summary>Быстрое преобразование Фурье</summary>
        </member>
        <member name="M:MathService.DSP.Fourier.FFT.FastFurierTransform(System.Double[])">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FFT.FastFurierTransform(MathService.Complex[])">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FFT.FastFurierInverse(MathService.Complex[])">
            <summary>Обратное преобразование отсчётов спектра в отсчёты сигнала</summary>
            <param name="Spectrum">Массив отсчётов спектра</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FFT.FFT_int(System.Int32[],System.Boolean)">
            <summary>
            Целочисленное преобразование Фурье
            </summary>
            <param name="a">Массив целых чисел</param>
            <param name="invert">Обратное преобразование</param>
        </member>
        <member name="T:MathService.DSP.Fourier.FT">
            <summary>Класс преобразования Фурье</summary>
        </member>
        <member name="M:MathService.DSP.Fourier.FT.FurierTransform(System.Double[],System.Boolean)">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
            <param name="IsInverse">Обратное преобразование</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FT.FurierTransform(MathService.Complex[],System.Boolean)">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
            <param name="Inverse">Обратное преобразование</param>
        </member>
        <member name="T:MathService.DSP.Signals.DigitalSignal">
            <summary>Цифровой сигнал</summary>
            <summary>Цифровой сигнал</summary>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.GetIntegralSignal">
            <summary>Цифровой сигнал - интеграл от текущего сигнала</summary>
            <returns>Интегральный сигнал без интерполяции</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.PowerOf(System.Double)">
            <summary>Возведение сигнала в степень</summary>
            <param name="power">Показатель степени</param>
            <returns>
            Цифровой сигнал, каждый отсчёт которого равен отсчётам текущего сигнала, возведённым в степень
            </returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.TimeInverse">
            <summary>Инвертирование сигнала по времени</summary>
            <returns>Цифровой сигнал, инвертированный по времени</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.Corelate(MathService.DSP.Signals.DigitalSignal)">
            <summary>Кореляционный интеграл</summary>
            <param name="h">Сигнал, с которым производится кореляция</param>
            <returns>Цифровой сигнал, равный кореляционному интегралу между сигналами</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.SaveToStream(System.IO.Stream)">
            <summary>Сохранить в поток</summary>
            <param name="DataStream">Поток данных для сохранения</param>
        </member>
        <member name="F:MathService.DSP.Signals.DigitalSignal.f_Interpolator">
            <summary>Интерполятор промежуточных значений сигнала</summary>
        </member>
        <member name="F:MathService.DSP.Signals.DigitalSignal.f_dx">
            <summary>Значение шага дискретизации сигнала</summary>
        </member>
        <member name="F:MathService.DSP.Signals.DigitalSignal.f_x0">
            <summary>Временное смещение</summary>
        </member>
        <member name="F:MathService.DSP.Signals.DigitalSignal.f_Samples">
            <summary>Массив значений сигнала - отсчёты</summary>
        </member>
        <member name="F:MathService.DSP.Signals.DigitalSignal.f_Name">
            <summary>Название сигнала</summary>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.Name">
            <summary>Название сигнала</summary>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.dx">
            <summary>Шаг дискретизации сигнала по времени</summary>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.ValueInterpolator">
            <summary>Интерполятор значений сигнала в промежуточные моменты времени</summary>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.SamplesCount">
            <summary>Число отсчётов сигнала</summary>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.Length">
            <summary>Длительность сигнала</summary>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.x0">
            <summary>Временное смещение</summary>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.Item(System.Double)">
            <summary>Значение сигнала в момент времени t</summary>
            <param name="x">Момент времени</param>
            <returns>Значение сигнала в выбранный момент времени</returns>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.Item(System.Int32)">
            <summary>Отсчёт сигнала</summary>
            <param name="n">Номер отсчёта сигнала</param>
            <returns>Отсчёт сигнала с номером n</returns>
            <remarks>Если номер отсчёта выходит за пределы, генерируется исключение</remarks>
            <exception cref="T:System.IndexOutOfRangeException">При выходе за пределы массива значений</exception>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.Power">
            <summary>Мощность сигнала</summary>
            <remarks>Интеграл квадрата сигнала</remarks>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.Value_First">
            <summary>Первое значение сигнала</summary>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.Value_Last">
            <summary>Последнее значение сигнала</summary>
        </member>
        <member name="P:MathService.DSP.Signals.DigitalSignal.Samples">
            <summary>Получить выборку сигнала</summary>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.#ctor(System.Double,System.Double[])">
            <summary>Цифровой сигнал</summary>
            <param name="dx">Шаг дискретизации сигнала по времени</param>
            <param name="Samples"></param>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.#ctor(System.Double,System.Double,System.Double[])">
            <summary>Цифровой сигнал</summary>
            <param name="dx">Шаг дискретизации сигнала по времени</param>
            <param name="x0">Смещение сигнала по времени</param>
            <param name="Values"></param>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.#ctor(System.Double,System.Int32)">
            <summary>Цифровой сигнал</summary>
            <param name="dx">Шаг дискретизации сигнала по времени</param>
            <param name="N">Размер выбрки</param>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.#ctor(System.Double,System.Double,System.Int32)">
            <summary>Цифровой сигнал</summary>
            <param name="dx">Шаг дискретизации сигнала по времени</param>
            <param name="x0">Смещение сигнала по времени</param>
            <param name="N">Размер выбрки</param>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.#ctor(System.Double,System.Double)">
            <summary>Цифровой сигнал</summary>
            <param name="dx">Шаг дискретизации по времени</param>
            <param name="Length">Длительность сигнала</param>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.#ctor(System.Double,System.Double,System.Double)">
            <summary>Цифровой сигнал</summary>
            <param name="dx">Шаг дискретизации по времени</param>
            <param name="x0">Смещение сигнала по времени</param>
            <param name="Length">Длительность сигнала</param>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.#ctor(MathService.DSP.Signals.DigitalSignal)">
            <summary>Конструктор цифрового сигнала по образцу</summary>
            <param name="Signal">Цифровой сигнал - аналог для клонирования</param>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Addition(MathService.DSP.Signals.DigitalSignal,System.Double)">
            <summary>Оператор суммы цифрового сигнала и числа двойной точности</summary>
            <param name="s">Первое слогаемое - цифровой сигнал</param>
            <param name="Value">Второе слогаемое - число двойной точности</param>
            <returns>Цифровой сигнал, равноый сумме исходного цифрового сигнала и числа</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Addition(System.Double,MathService.DSP.Signals.DigitalSignal)">
            <summary>Оператор суммы цифрового сигнала и числа двойной точности</summary>
            <param name="s">Первое слогаемое - цифровой сигнал</param>
            <param name="Value">Второе слогаемое - число двойной точности</param>
            <returns>Цифровой сигнал, равноый сумме исходного цифрового сигнала и числа</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Subtraction(MathService.DSP.Signals.DigitalSignal,System.Double)">
            <summary>Оператор разности цифрового сигнала и числа двойной точности</summary>
            <param name="s">Уменьшаемое - цифровой сигнал</param>
            <param name="Value">Вычитаемое - число двойной точности</param>
            <returns>Цифровой сигнал, равноый разности исходного цифрового сигнала и числа</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Subtraction(System.Double,MathService.DSP.Signals.DigitalSignal)">
            <summary>Оператор разности цифрового сигнала и числа двойной точности</summary>
            <param name="s">Уменьшаемое - цифровой сигнал</param>
            <param name="Value">Вычитаемое - число двойной точности</param>
            <returns>Цифровой сигнал, равноый разности исходного цифрового сигнала и числа</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Multiply(MathService.DSP.Signals.DigitalSignal,System.Double)">
            <summary>Оператор произведения цифрового сигнала и числа двойной точности</summary>
            <param name="s">Первый сомножитель - цифровой сигнал</param>
            <param name="Value">Вторй сомножитель - число двойной точности</param>
            <returns>Цифровой сигнал, равноый произведению исходного цифрового сигнала и числа</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Multiply(System.Double,MathService.DSP.Signals.DigitalSignal)">
            <summary>Оператор произведения цифрового сигнала и числа двойной точности</summary>
            <param name="s">Первый сомножитель - цифровой сигнал</param>
            <param name="Value">Вторй сомножитель - число двойной точности</param>
            <returns>Цифровой сигнал, равноый произведению исходного цифрового сигнала и числа</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Division(MathService.DSP.Signals.DigitalSignal,System.Double)">
            <summary>Оператор отношения цифрового сигнала и числа двойной точности</summary>
            <param name="s">Делимое - цифровой сигнал</param>
            <param name="Value">Делитель - число двойной точности</param>
            <returns>Цифровой сигнал, равноый отношению исходного цифрового сигнала и числа</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Division(System.Double,MathService.DSP.Signals.DigitalSignal)">
            <summary>Оператор отношения цифрового сигнала и числа двойной точности</summary>
            <param name="s">Делимое - цифровой сигнал</param>
            <param name="Value">Делитель - число двойной точности</param>
            <returns>Цифровой сигнал, равноый отношению исходного цифрового сигнала и числа</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Addition(MathService.DSP.Signals.DigitalSignal,MathService.DSP.Signals.DigitalSignal)">
            <summary>Оператор суммы двух сигналов</summary>
            <param name="s1">Первое слогаемое - цифровой сигнал</param>
            <param name="s2">Второе слогаемое - цифровой сигнал</param>
            <returns>Цифровой сигнал - сумма двух сигналов</returns>
        </member>
        <member name="M:MathService.DSP.Signals.DigitalSignal.op_Subtraction(MathService.DSP.Signals.DigitalSignal,MathService.DSP.Signals.DigitalSignal)">
            <summary>Оператор разности двух сигналов</summary>
            <param name="s1">Уменьшаемое - цифровой сигнал</param>
            <param name="s2">Вычитаемое - цифровой сигнал</param>
            <returns>Цифровой сигнал - сумма двух сигналов</returns>
        </member>
        <member name="T:MathService.DSP.Signals.HarmonicSignal">
            <summary>Гармонический сигнал</summary>
        </member>
        <member name="P:MathService.DSP.Signals.Noice.WhiteNoiceSignal.D">
            <summary>Дисперсия</summary>
        </member>
        <member name="P:MathService.DSP.Signals.Noice.WhiteNoiceSignal.M">
            <summary>Мат.ожидание</summary>
        </member>
        <member name="P:MathService.DSP.Signals.Noice.WhiteNoiceSignal.RandomSample">
            <summary>Случайное значение</summary>
        </member>
        <member name="M:MathService.DSP.Signals.Noice.WhiteNoiceSignal.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>Случайный сигнал</summary>
            <param name="dx">Шаг дискретизации</param>
            <param name="Length">Длительность</param>
            <param name="D">Дисперсия</param>
            <param name="M">Мат.ожидание</param>
        </member>
        <member name="T:MathService.DSP.Signals.SpectrumSignal">
            <summary>Спектр сигнала</summary>
        </member>
        <member name="F:MathService.DSP.Signals.SpectrumSignal.f_ImValues">
            <summary>Массив отсчётов мнимой составляющей спектра</summary>
        </member>
        <member name="T:MathService.DSP.Signals.PeriodicDigitalSignal">
            <summary>Периодический цифровой сигнал</summary>
        </member>
        <member name="T:MathService.DSP.DelayLine">
            <summary>Линия задержки</summary>
        </member>
        <member name="F:MathService.DSP.DelayLine.f_z">
            <summary>Память линии задержки</summary>
        </member>
        <member name="F:MathService.DSP.DelayLine.f_k">
            <summary>Указатель на первый элемент с области памяти линии задержки</summary>
        </member>
        <member name="P:MathService.DSP.DelayLine.K">
            <summary>Указатель на первую ячейку памяти в линии задержки</summary>
        </member>
        <member name="P:MathService.DSP.DelayLine.Length">
            <summary>Значения в линии задержки</summary>
            <summary>Длина линии задержки</summary>        
        </member>
        <member name="P:MathService.DSP.DelayLine.Item(System.Int32)">
            <param name="i">Номер элемента линии</param>
            <returns>Значение элемента в линии задержки</returns>
        </member>
        <member name="P:MathService.DSP.DelayLine.First">
            <summary>Первый элемент линии задержки</summary>
        </member>
        <member name="P:MathService.DSP.DelayLine.Last">
            <summary>Последний элемент линии задержки</summary>
        </member>
        <member name="M:MathService.DSP.DelayLine.#ctor(System.Int32)">
            <summary>Новая линия задержки</summary>
            <param name="Length">Длина линии задержки</param>
        </member>
        <member name="M:MathService.DSP.DelayLine.Initialize">
            <summary>Инициализировать линию задержки - обнуление всех значений</summary>
        </member>
        <member name="M:MathService.DSP.DelayLine.GetAddress(System.Int32)">
            <summary>Получить адрес элемента в области памяти линии задержки через порядковый номер</summary>
            <param name="i">Порядковый номер элемента в линии задержки</param>
            <returns>Значение элемента в линии задержки</returns>
        </member>
        <member name="M:MathService.DSP.DelayLine.Shift">
            <summary>Сдвинуть линию на один элемент вперёд</summary>
        </member>
        <member name="M:MathService.DSP.DelayLine.Shift(System.Int32)">
            <summary>Сдинуть линию на n элементов вперёд</summary>
            <param name="n">Размер сдвига</param>
        </member>
        <member name="M:MathService.DSP.DelayLine.Return">
            <summary>сдинуть линию на один элемент назад</summary>
        </member>
        <member name="M:MathService.DSP.DelayLine.Return(System.Int32)">
            <summary>Сдинуть линию на n элементов назад</summary>
            <param name="n">Размер сдвига</param>
        </member>
        <member name="M:MathService.DSP.DelayLine.AddFirst(System.Double)">
            <summary>Добавить элемент в линию задержки первым со смещением всех элементов вперёд</summary>
            <param name="value">Добавляемое значение</param>
        </member>
        <member name="M:MathService.DSP.DelayLine.AddLast(System.Double)">
            <summary>Добавить элемент в линию задержки последним со смещением всех жлементов назад</summary>
            <param name="value">Добавляемое значение</param>
        </member>
        <member name="M:MathService.DSP.DelayLine.GetHashCode">
            <summary>Получить Хэш-код объекта</summary>
            <returns>Хэш-код объекта</returns>
        </member>
        <member name="M:MathService.DSP.DelayLine.Equals(System.Object)">
            <summary>Сравнить текущий объект с...</summary>
            <param name="obj">Сравниваемый объект</param>
            <returns>Линии считаются равными, если они одинаковой длины и значения их элементов равны</returns>
        </member>
        <member name="T:MathService.DSP.IDigitalFilter">
            <summary>Интерфейс цифрового фильтра</summary>
        </member>
        <member name="M:MathService.DSP.IDigitalFilter.GetImpulseResponse(System.Double,System.Double)">
            <summary>Получить импульсную характеристику</summary>
            <param name="dt">Период дискретизации в секундах</param>
            <param name="Length">Длина выборки в секундах</param>
            <returns>Цифровой сигнал - импульсная характеристика</returns>
        </member>
        <member name="M:MathService.DSP.IDigitalFilter.Initialize">
            <summary>Инициализировать фильтр</summary>
        </member>
        <member name="P:MathService.DSP.IDigitalFilter.Order">
            <summary>Порядок фильтра</summary>
        </member>
        <member name="M:MathService.DSP.IDigitalFilter.Process(System.Double)">
            <summary>Обработать отсчёт</summary>
            <param name="x_n">Обрабатываемый отсчёт</param>
            <returns>Результат прохождения отсчёта через фильтр</returns>
        </member>
        <member name="M:MathService.DSP.IDigitalFilter.ProcessSignal(MathService.DSP.Signals.DigitalSignal)">
            <summary>Обработать цифровой сигнал</summary>
            <param name="s">Входное воздействие</param>
            <returns>Выходной сигнал</returns>
        </member>
        <member name="M:MathService.DSP.IDigitalFilter.ProcessSignal(System.Double[])">
            <summary>Обработать выборку отсчётов</summary>
            <param name="x">Входное воздействие в виде выборки отсчётов</param>
            <returns>Результирующая выборка отсчётов</returns>
        </member>
        <member name="T:MathService.DSP.CBIH">
            <summary>Цифровой фильтр с бесконечной импульсной характеристикой</summary>
        </member>
        <member name="F:MathService.DSP.CBIH.f_a">
            <summary>Коэффициенты прямого фильтра</summary>
        </member>
        <member name="F:MathService.DSP.CBIH.f_b">
            <summary>Коэффициенты реверсивного фильтра</summary>
        </member>
        <member name="P:MathService.DSP.CBIH.Value">
            <summary>Текущее щначение на выходе фильтра</summary>
        </member>
        <member name="M:MathService.DSP.CBIH.#ctor(System.Double[],System.Double[])">
            <summary>Фильтр с бесконечной импульсной характеристикой</summary>
            <param name="a">Массив коэффициентов прямого фильтра</param>
            <param name="b">Массив коэффициентов реверсивного фильтра</param>
        </member>
        <member name="M:MathService.DSP.CBIH.Initialize(System.Double[],System.Double[])">
            <summary>Иницифлизация начального состояния фильтра с новыми коэффициентами</summary>
            <param name="a">Массив коэффициентов прямого фильтра</param>
            <param name="b">Массив коэффициентов реверсивного фильтра</param>
        </member>
        <member name="M:MathService.DSP.CBIH.Process(System.Double)">
            <summary>Обработка единичного отсчёта сигнала</summary>
            <param name="x_n">Единичный отсчёт входного воздействия</param>
            <returns>Отклик фильтра на входное воздействие</returns>
        </member>
        <member name="M:MathService.DSP.CBIH.Process_KIH(System.Double,System.Double[],MathService.DSP.DelayLine)">
            <summary>Обработка входного воздействия в КИХ режиме</summary>
            <param name="x_n">Единичное входное воздействие</param>
            <param name="b">Массив коэффициентов прямого фильтра</param>
            <param name="Line">Линия задержки фильтра</param>
            <returns>Отклик фильтра</returns>
        </member>
        <member name="M:MathService.DSP.CBIH.Process_Recurs(System.Double,System.Double[],MathService.DSP.DelayLine)">
            <summary>Обработка рекурсивным фильтром</summary>
            <param name="x_n">Единичный отсчёт входного воздействия</param>
            <param name="a">Коэффициенты рекурсивного фильтра</param>
            <param name="Line">Линия задержки фильтра</param>
            <returns></returns>
        </member>
        <member name="M:MathService.DSP.CBIH.Process_BIH(System.Double,System.Double[],System.Double[],MathService.DSP.DelayLine)">
            <summary>Обработка входного воздействия фильтром с бесконечной импульсной эарактеристикой</summary>
            <param name="x_n">Единичный отсчёт входного водействия</param>
            <param name="a">Масив коэффициентов прямого фильтра</param>
            <param name="b">Массив коэффициентов рекурсивного фильтра</param>
            <param name="Line">Линия задержки фильтра</param>
            <returns>Отклик фильтра</returns>
        </member>
        <member name="T:MathService.ExpressionCreator`1">
            <example>
            internal class DirectCreator : ICreator&lt;Foo&gt;
            {
              public Foo Create(Dictionary&lt;string, object&gt; props)
                {
                    return new Foo
                    {
                        Name = props.GetValue&lt;string&gt;("Name"),
                        Value = props.GetValue&gt;int&lt;("Value")
                    };
                }
            }
            </example>
        </member>
        <member name="M:MathService.Extentions.Expressions.ExpressionExtentions.Substitute(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.LambdaExpression)">
            <exception cref="T:System.FormatException">Количество аргументов подстановки не равно 1, или во входном выражении отсутсвуте подставляемый параметр</exception>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.isSogl(System.Char)">
            <summary>Проверяет, является ли символ согласным</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.isGlas(System.Char)">
            <summary>Проверяет, является ли символ гласным</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.isSpecSign(System.Char)">
            <summary>Проверяет, является ли символ специальным (в данном контексте - разделителем)</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.GetSymbType(System.Char)">
            <summary>Возвращает тип символа: согласный, гласный, разделитель, неопределен</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.isSlogMore(MathService.Extentions.String.WordWrap.SymbType[],System.Int32)">
            <summary>Определяет, можно ли сделать перенос в массиве "с" в промежутке от start до len</summary>
            <param name="c"></param><param name="Start"></param><returns></returns>
            <remarks>
            Как я понимаю используется вместе с предыдущей функцией, т.е. сперва с помощью GetSymbType получить 
            из слова массив SymbType и дальше с помощью данной функции проверить, можно ли в нем сделать перенос
            </remarks>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.SetHyph(System.String,System.Int32)">
            <summary>Фактически, она и проделывает всю работу</summary>
            <param name="pc">Входной масив символов</param>
            <param name="MaxSize">Максимальный размер</param>
            <returns>Строка с расставленными знаками переноса</returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.Red_GlasMore(System.String,System.Int32)">
            <summary>
            На вход функции подается указатель на строку и позиция символа, с которого начинается чтение. 
            Дальше функция проверяет, есть ли в данной строке гласная буква
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.Red_SlogMore(System.String,System.Int32)">
            <summary>
            Аналогично предыдущей функции, но для согласных
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.MayBeHyph(System.String,System.Int32)">
            <summary>
            На вход подается указатель на строку и позиция, с которого начинается чтение. 
            Функция проверяет, можно ли сделать в данной строке перенос
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.SetHyphString(System.String)">
            <summary>На вход ей подается просто некая строка, дальше она ее обрабатывает и возвращает строку с переносами</summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Functions.PSO.Swarm1D.Minimize(System.Func{System.Double,System.Double},MathService.Interval,System.Int32,System.Double@,System.Double@)">
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="T:MathService.Functions.PSO.Swarm2D">
            <summary>Рой двумерных частиц</summary>
        </member>
        <member name="F:MathService.Functions.PSO.Swarm2D.w">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathService.Functions.PSO.Swarm2D.c1">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="F:MathService.Functions.PSO.Swarm2D.c2">
            <summary>Коэффициент глобального веса</summary>
        </member>
        <member name="T:MathService.Functions.PSO.Swarm2D.Particle2D">
            <summary>Частица</summary>
        </member>
        <member name="F:MathService.Functions.PSO.Swarm2D.f_ParticleCount">
            <summary>Размер роя</summary>
        </member>
        <member name="T:MathService.GCWacher">
            <summary>Наблюдатель за сборщиком мусора</summary>
        </member>
        <member name="E:MathService.GCWacher.sf_Approaches">
            <summary>Событие запуска процесса сборки мусора</summary>
        </member>
        <member name="E:MathService.GCWacher.Approaches">
            <summary>Событие запуска процесса сборки мусора</summary>
        </member>
        <member name="E:MathService.GCWacher.sf_Complite">
            <summary>Событие завершения процесса сборки мусора</summary>
        </member>
        <member name="E:MathService.GCWacher.Complite">
            <summary>Событие завершения процесса сборки мусора</summary>
        </member>
        <member name="M:MathService.GCWacher.OnApproaches">
            <summary>Генерация осбытия начала сборки мусора</summary>
        </member>
        <member name="M:MathService.GCWacher.OnComplite">
            <summary>Генерация осбытия окончания сборки мусора</summary>
        </member>
        <member name="F:MathService.GCWacher.sf_GCWacher">
            <summary>Объект-наблюдатель за сборщиком мусора</summary>
        </member>
        <member name="F:MathService.GCWacher.sf_SyncRoot">
            <summary>Объект синхронизации потоков управления наблюдателем</summary>
        </member>
        <member name="F:MathService.GCWacher.f_WatcherThread">
            <summary>Поток наблюдения с борщиком мусора</summary>
        </member>
        <member name="F:MathService.GCWacher.sf_Enabled">
            <summary>Признак активности наблюдателя</summary>
        </member>
        <member name="M:MathService.GCWacher.#ctor">
            <summary>Скрытая инициализация объекта-наблюдателя</summary>
        </member>
        <member name="M:MathService.GCWacher.Start">
            <summary>Запуск процесса наблюдения</summary>
        </member>
        <member name="M:MathService.GCWacher.Stop">
            <summary>Остановка процесса наблюдения</summary>
        </member>
        <member name="M:MathService.GCWacher.Watch">
            <summary>Проесс наблюдения</summary>
        </member>
        <member name="M:MathService.Graphs.GraphEx.AsGraphNode``2(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,``0,``1},System.Boolean)">
            <summary>Преобразование к типу вершины графа</summary>
            <typeparam name="V">Тап значения вершины</typeparam>
            <typeparam name="W">Тип веса связи</typeparam>
            <param name="value">Значение вершины</param>
            <param name="GetChields">Метод выделения дочерних узлов</param>
            <param name="GetWeight">Метод определения веса связи между узлами</param>
            <param name="Buffered">Буферизация узлов и связей</param>
            <returns>Узел графа</returns>
            <example>
            <code>
            var M = new[,]
                   { /* 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14*/
            /*  0 */   {0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  1 */   {1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  2 */   {1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  3 */   {0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0},
            /*  4 */   {0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0},
            /*  5 */   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
            /*  6 */   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
            /*  7 */   {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  8 */   {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  9 */   {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 10 */   {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 11 */   {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 12 */   {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 13 */   {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 14 */   {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                   };
            var node = new { M, i = 0 };
            var root = node.AsGraphNode(r => Enumerable.Range(0, r.M.GetLength(1)).Select(i => new { M, i }),
                         (from, to) => from.M[to.i, from.i]);
            var tree = root.AsGraphNode(root => root.Links.Where(link => link.Weight == 1)
                                                          .Select(link => link.Node),
                                        (from, to) => to.Value.i - from.Value.i);
            var rouht = tree.GetWaveRouth();
            
            </code>
            </example>
        </member>
        <member name="M:MathService.Graphs.GraphEx.AsGraphNode``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
            <summary>Преобразование к виду графа</summary>
            <typeparam name="V">Тип преобразуемого объекта</typeparam>
            <param name="value">Преобразуемый объект</param>
            <param name="GetChields">Метод извлечения дочерних узлов из каждого узла графа</param>
            <param name="Buffered">Флаг необходимости проведения буфферизации</param>
            <returns></returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.BypassInDepth``2(MathService.Graphs.IGraphNode{``0,``1})">
            <summary>Метод перебора вершин графа путём обхода "в глубину". Обход на основе стека дочерних узлов.</summary>
            <typeparam name="V">Тип узлов графа</typeparam>
            <typeparam name="W">Тип связи узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.BypassInDepth``1(MathService.Graphs.IGraphNode{``0})">
            <summary>Метод перебора вершин графа путём обхода "в глубину". Обход на основе стека дочерних узлов.</summary>
            <typeparam name="V">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.BaypassInWidth``2(MathService.Graphs.IGraphNode{``0,``1})">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов.</summary>
            <typeparam name="V">Тип узлов графа</typeparam>
            <typeparam name="W">Тип связи узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.BaypassInWidth``1(MathService.Graphs.IGraphNode{``0})">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов.</summary>
            <typeparam name="V">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.FindRouthInDepth``2(MathService.Graphs.IGraphNode{``0,``1},System.Predicate{``0})">
            <summary>МЕтод поиска пути в графе путём обхода вершин "в глубину"</summary>
            <typeparam name="V">Тип вершины графа</typeparam>
            <typeparam name="W">Тип связи вершин графа</typeparam>
            <param name="RootNode">Начальный элемент поиска пути</param>
            <param name="FindPredicate">Метод определения окончания поиска, как успешного</param>
            <returns>Маршрут в графе</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.GetWaveRouth``2(MathService.Graphs.IGraphNode{``0,``1})">
            <summary>Метод поиска всех путей из указанной вершины до всех доступных вершин графа методом фронта волны</summary>
            <typeparam name="V">Тип вершины графа</typeparam>
            <typeparam name="W">Тип связи вершин графа</typeparam>
            <param name="Root">Начальный элемент поиска пути</param>
            <returns>Массив найденных путей</returns>
        </member>
        <member name="T:MathService.Graphs.IGraphLink`2">
            <summary>Связь узла</summary>
            <typeparam name="V">Тип значения узла</typeparam>
            <typeparam name="W">Тип нагрузки на связь</typeparam>
        </member>
        <member name="P:MathService.Graphs.IGraphLink`2.Node">
            <summary>Связанный узел</summary>
        </member>
        <member name="P:MathService.Graphs.IGraphLink`2.Weight">
            <summary>Нагрузка на связь</summary>
        </member>
        <member name="T:MathService.Graphs.IGraphNode`2">
            <summary>Узел графа</summary>
            <typeparam name="V">Тип значения узла</typeparam>
            <typeparam name="W">Тип нагрузки на связь</typeparam>
        </member>
        <member name="P:MathService.Graphs.IGraphNode`2.Links">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathService.Graphs.IGraphNode`2.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathService.Graphs.IGraphNode`1.Childs">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathService.Graphs.IGraphNode`1.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathService.Graphs.LambdaGraphNode`1.Childs">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathService.Graphs.LambdaGraphNode`1.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.IndexOf(MathService.Graphs.TreeListNode{`0})">
            <summary>
            Определяет индекс заданного элемента коллекции <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>
            Индекс <paramref name="item"/> если он найден в списке; в противном случае его значение равно -1.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.IndexOf(`0)">
            <summary>
            Определяет индекс заданного элемента коллекции <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>
            Индекс <paramref name="item"/> если он найден в списке; в противном случае его значение равно -1.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Insert(System.Int32,MathService.Graphs.TreeListNode{`0})">
            <summary>
            Вставляет элемент в список <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.
            </summary>
            <param name="index">Индекс (с нуля), по которому следует вставить параметр <paramref name="item"/>.</param><param name="item">Объект, вставляемый в <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Insert(System.Int32,`0)">
            <summary>
            Вставляет элемент в список <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.
            </summary>
            <param name="index">Индекс (с нуля), по которому следует вставить параметр <paramref name="item"/>.</param><param name="item">Объект, вставляемый в <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.RemoveAt(System.Int32)">
            <summary>
            Удаляет элемент <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.
            </summary>
            <param name="index">Индекс (с нуля) удаляемого элемента.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathService.Graphs.TreeListNode`1.System#Collections#Generic#IList{TValue}#Item(System.Int32)">
            <summary>
            Получает или задает элемент по указанному индексу.
            </summary>
            <returns>
            Элемент с указанным индексом.
            </returns>
            <param name="index">Индекс (с нуля) элемента, который необходимо получить или задать.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Свойство задано, и объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{TValue}#Add(`0)">
            <summary>
            Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Clear">
            <summary>
            Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения. </exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Contains(`0)">
            <summary>
            Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.CopyTo(`0[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="arrayIndex">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="arrayIndex"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="arrayIndex"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="TValue"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Remove(`0)">
            <summary>
            Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathService.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{TValue}#Count">
            <summary>
            Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Contains(MathService.Graphs.TreeListNode{`0})">
            <summary>
            Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.CopyTo(MathService.Graphs.TreeListNode{`0}[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="arrayIndex">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="arrayIndex"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="arrayIndex"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="T"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Remove(MathService.Graphs.TreeListNode{`0})">
            <summary>
            Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathService.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{MathService#Graphs#TreeListNode{TValue}}#Count">
            <summary>
            Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:MathService.Graphs.TreeListNode`1.IsReadOnly">
            <summary>
            Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.
            </summary>
            <returns>
            Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.
            </returns>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.System#Collections#Generic#IEnumerable{TValue}#GetEnumerator">
            <summary>
            Возвращает перечислитель, выполняющий перебор элементов в коллекции.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="T:MathService.Interpolation.BezierCurve">
            <summary><see cref="!:http://ru.wikipedia.org/wiki/Кривая_Безье">Кривая Безье</see></summary>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.BinomCoefficient(System.Int32,System.Int32)">
            <summary>
            Биномиальный коэффициент (1+x)^n из <paramref name="n"/> по <paramref name="k"/>
            <see cref="!:http://ru.wikipedia.org/wiki/Биномиальный_коэффициент">Википедия:Биномиальный коэффициент</see>>
            </summary>
            <param name="n">Степень <see cref="!:http://ru.wikipedia.org/wiki/Бином_Ньютона">бинома Ньютона</see>></param>
            <param name="k">Номер коэффициента</param>
            <returns>Коэффициент разложения Бинома Ньютона (1+x)^n</returns>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.GetBernshteynPolynom(System.Int32,System.Int32)">
            <summary>Получить <see cref="!:http://ru.wikipedia.org/wiki/Многочлен_Бернштейна">Полином Бернштейна</see>></summary>
            <param name="k">Номер многочлена</param>
            <param name="n">Степень</param>
            <returns></returns>
        </member>
        <member name="F:MathService.Interpolation.BezierCurve.f_Points">
            <summary>Набор точек аппроксимации</summary>
        </member>
        <member name="F:MathService.Interpolation.BezierCurve.f_BernshteynPolynoms">
            <summary><see cref="!:http://ru.wikipedia.org/wiki/Многочлен_Бернштейна">Полином Бернштейна</see>></summary>        
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Новая <see cref="!:http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="X">Список координато точек x</param>
            <param name="Y">Список кординат точек y</param>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{MathService.Complex})">
            <summary>Новая <see cref="!:http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="Points">Набор точек в виде <see cref="T:MathService.Complex">комплексных чисел</see></param>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{MathService.Vectors.Vector2D})">
            <summary>Новая <see cref="!:http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="Points">Набор точек</param>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.Initialize(System.Collections.Generic.IEnumerable{MathService.Vectors.Vector2D})">
            <summary>Инициализировать кривую Безье</summary>
            <param name="Points">Набор точек</param>
        </member>
        <member name="T:MathService.Interpolation.CubicSpline">
            <summary>Интерполирование функций естественными кубическими сплайнами</summary>
            <remarks>Разработчик: Назар Андриенко Email: nuzikprogrammer@gmail.com</remarks>
        </member>
        <member name="T:MathService.Interpolation.CubicSpline.SplineState">
            <summary>Структура, описывающая сплайн на каждом сегменте сетки</summary>
        </member>
        <member name="F:MathService.Interpolation.CubicSpline.f_SplinStates">
            <summary>Сплайн</summary>
        </member>
        <member name="M:MathService.Interpolation.CubicSpline.Initialize(System.Double[],System.Double[])">
            <summary>Инициализация сплайна</summary>
            <param name="X">Массив аргументов</param><param name="Y">Массив значений</param>
            <exception cref="T:System.ArgumentException">Возникает в случае, если размерности массивов не равны</exception>
        </member>
        <member name="T:MathService.Interpolation.IInterpolator">
            <summary>Интерфейс интерполяции</summary>
        </member>
        <member name="M:MathService.Interpolation.IInterpolator.Value(System.Double)">
            <summary>Получить значение</summary>
            <param name="x">Переменная</param>
            <returns>Значение</returns>
        </member>
        <member name="T:MathService.MathParser.BlockTerm">
            <summary>Элемент мат.выражения - блок со скобками</summary>
        </member>
        <member name="F:MathService.MathParser.BlockTerm.f_OpenBracket">
            <summary>Строковое значение открывающейся скобки</summary>
        </member>
        <member name="F:MathService.MathParser.BlockTerm.f_CloseBracket">
            <summary>Строковое значение закрывающейся скобки</summary>
        </member>
        <member name="F:MathService.MathParser.BlockTerm.f_Terms">
            <summary>Массив элементов подвыражения</summary>
        </member>
        <member name="P:MathService.MathParser.BlockTerm.OpenBracket">
            <summary>Строковое значение открывающейся скобки</summary>
        </member>
        <member name="P:MathService.MathParser.BlockTerm.CloseBracket">
            <summary>Строковое значение закрывающейся скобки</summary>
        </member>
        <member name="P:MathService.MathParser.BlockTerm.Terms">
            <summary>Массив элементов подвыражения</summary>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.#ctor(System.String)">
            <summary>Новый блок математического выражения</summary>
            <param name="Str">Строковое значение блока</param>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.#ctor(System.String,System.String,System.String)">
            <summary>Новый блок выражения</summary>
            <param name="OpenBracket">Открывающаяся скобка</param>
            <param name="Str">Строковое значение блока</param>
            <param name="CloseBracket">Закрывающаяся скобка</param>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.GetNumberString(System.String,System.Int32@)">
            <summary>Получить цифровую строку</summary>
            <param name="Str">Исследуемая строка</param>
            <param name="pos">Исходная позиция в строке</param>
            <returns>Строка цифрового значения</returns>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.GetNameString(System.String,System.Int32@)">
            <summary>Получить имя из строки</summary>
            <param name="Str">Исходная строка</param>
            <param name="pos">Положение в строке</param>
            <returns>Строка имени</returns>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.GetTerms(System.String)">
            <summary>Получить список элементов математического выражения из строки</summary>
            <param name="Str">Строковое представление математического выражения</param>
            <returns>Массив элементов математического выражения</returns>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.ToString">
            <summary>Преборазование в строковое представление</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Получить корень поддерева выражений</summary>
            <param name="Parser">Парсер выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Корень поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.NewRound">
            <summary>Круглые скобки</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.NewRect">
            <summary>Квадратные скобки</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.NewFigur">
            <summary>Фигурные скобки</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.Start">
            <summary>Открывающая скобка</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.Stop">
            <summary>Закрывающая скобка</summary>
        </member>
        <member name="M:MathService.MathParser.Bracket.#ctor(System.String,System.String)">
            <summary>Скобки</summary>
            <param name="Start">Строка открывающей скобки</param>
            <param name="Stop">Строка закрывающей скобки</param>
        </member>
        <member name="M:MathService.MathParser.Bracket.Equals(MathService.MathParser.Bracket)">
            <summary>Проверка на эквивалентность другим скобкам</summary>
            <param name="other">Проверяемые на эквивалентность скобки</param>
            <returns>Истина, если проверяемые скобки эквивалентны данным</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.Equals(System.Object)">
            <summary>Проверка на эквивалентность</summary>
            <param name="obj">Проверяемый объект</param>
            <returns>Истина, если объект - скобки и вид скобок совпадает</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.GetHashCode">
            <summary>Получить хэш-код</summary>
            <returns>Хэш-код</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.Clone">
            <summary>Клонирование скобок</summary>
            <returns>Клон скобок</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.ToString">
            <summary>Строковое представление скобок</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.Suround(System.String)">
            <summary>Разместить текст в скобках</summary>
            <param name="str">Размещаемый текст</param>
            <returns>Текст в скобках</returns>
        </member>
        <member name="T:MathService.MathParser.CharTerm">
            <summary>Символьный элемент математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.CharTerm.Value">
            <summary>Символьное значение элемента</summary>
        </member>
        <member name="M:MathService.MathParser.CharTerm.#ctor(System.Char)">
            <summary>Новый символьный элемент</summary>
            <param name="c">Символьное значение элемента</param>
        </member>
        <member name="M:MathService.MathParser.CharTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Получить поддерево</summary>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Результат вызова метода Parser.GetOperatorNode(Value)</returns>
        </member>
        <member name="T:MathService.MathParser.FunctionalsCollection">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="F:MathService.MathParser.FunctionalsCollection.f_Operators">
            <summary>Список функционалов</summary>
        </member>
        <member name="F:MathService.MathParser.FunctionalsCollection.f_Expression">
            <summary>Ссылка на математическое выражение, с которым связана поллекция</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionalsCollection.Count">
            <summary>Количество функционалов в коллекции</summary>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.#ctor(MathService.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции функционалов</summary>
            <param name="Expression">Математическое выражение, на которое ссылается коллекция</param>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.Add(MathService.MathParser.Functional)">
            <summary>Добавить функционал в коллекцию</summary>
            <param name="Operator">Добавляемый функционал</param>
            <returns>Истина, если добавление прошло успешно</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.System#Collections#Generic#IEnumerable{MathService#MathParser#Functional}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An enumerator that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.MathParser.Functional">
            <summary>Функционал</summary>
        </member>
        <member name="M:MathService.MathParser.Functional.#ctor(System.String)">
            <summary>Инициализация нового функционала</summary>
            <param name="Name">Имя функционала</param>
        </member>
        <member name="M:MathService.MathParser.Functional.GetValue">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="M:MathService.MathParser.Functional.GetValue(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <param name="ParametersExpression">Выражение параметров</param>
            <param name="Function">Ядро функционала</param>
            <returns>Численное значение вычисленного выражения</returns>
        </member>
        <member name="M:MathService.MathParser.Functional.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathService.MathParser.Functional.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Выражение ядра функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathService.MathParser.Functional.Initialize(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Внешнее мат.выражение</param>
        </member>
        <member name="T:MathService.MathParser.FunctionalTerm">
            <summary>Блок определения функции</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionalTerm.Parameters">
            <summary>Параметры оператора</summary>
        </member>
        <member name="M:MathService.MathParser.FunctionalTerm.#ctor(MathService.MathParser.FunctionTerm,MathService.MathParser.BlockTerm)">
            <summary>Инициализация блока комплексного оператора</summary>
            <param name="Header">Заголовок блока</param>
            <param name="Body">Тело блока</param>
        </member>
        <member name="M:MathService.MathParser.FunctionalTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Получить поддерево комплексного оператора</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел комплексного оператора</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionalTerm.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление элемента</returns>
        </member>
        <member name="T:MathService.MathParser.ConstantsCollection">
            <summary>Коллекция констант</summary>
        </member>
        <member name="F:MathService.MathParser.ConstantsCollection.f_Expression">
            <summary>Ссылка на выражение</summary>
        </member>
        <member name="F:MathService.MathParser.ConstantsCollection.f_Items">
            <summary>Элементы коллекци</summary>
        </member>
        <member name="P:MathService.MathParser.ConstantsCollection.Count">
            <summary>Количество элементов коллекции</summary>
        </member>
        <member name="P:MathService.MathParser.ConstantsCollection.Item(System.String)">
            <summary>Итератор констант по имени</summary>
            <param name="Name">Имя константы</param>
            <returns>Константа с указанным именем</returns>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.#ctor(MathService.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции констант</summary>
            <param name="Expression">Математическое выражение, которому принадлежит коллекция</param>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.Add(MathService.MathParser.ExpressionVariabel)">
            <summary>Добавить элемент в коллекцию</summary>
            <param name="Constant">Добавляемое значение, как константа</param>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.GetNames">
            <summary>Получить имена констант колеекции</summary>
            <returns>Перечисление имён констант колеекции</returns>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.System#Collections#Generic#IEnumerable{MathService#MathParser#ExpressionVariabel}#GetEnumerator">
            <summary>Получить перечислитеь констант коллекци</summary>
            <returns>Перечислитель констант</returns>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитеь констант коллекци</summary>
            <returns>Перечислитель констант</returns>
        </member>
        <member name="T:MathService.MathParser.EventExpressionVariable">
            <summary>Событийная переменная</summary>
            <remarks>Переменная математического выражения, значение которой определяется через генерацию события</remarks>
        </member>
        <member name="E:MathService.MathParser.EventExpressionVariable.Call">
            <summary>Событие запроса значения переменной</summary>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.OnCall(System.EventArgs{System.Double})">
            <summary>Метод генерации события</summary>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="F:MathService.MathParser.EventExpressionVariable.f_EventArg">
            <summary>Аргумент события</summary>
        </member>
        <member name="F:MathService.MathParser.EventExpressionVariable.f_ClearAtCall">
            <summary>Флаг предварительной очистки значения аргумента события</summary>
        </member>
        <member name="P:MathService.MathParser.EventExpressionVariable.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:MathService.MathParser.EventExpressionVariable.IsPrecomputable">
            <summary>Признак предвычислимости всегда = false</summary>
        </member>
        <member name="P:MathService.MathParser.EventExpressionVariable.ClearAtCall">
            <summary>Флаг предварительной очистки значения аргумента события</summary>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.#ctor">
            <summary>Инициализация новой событийной переменной</summary>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.#ctor(System.String)">
            <summary>Инициализация новой событийной переменной</summary>
            <param name="Name">Имя переменной</param>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.GetValue">
            <summary>Получение значения переменной</summary>
            <returns>Значение переменой</returns>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.Clone">
            <summary>Метод клонирования событийной переменной</summary>
            <returns>Клонированная событийная переменная</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionFunction">
            <summary>функция в структуре математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionFunction.Delegate">
            <summary>Делегат функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionFunction.Arguments">
            <summary>Массив имён аргументов</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.#ctor(System.String,System.String[])">
            <summary>Инициализация новой функции структуры математического выражения по сигнатуре</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">списко имён аргументов</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.GetValue(System.Double[])">
            <summary>Метод получения значения функции по массиву значений её аргументов</summary>
            <param name="arguments">Массив аргументов функции</param>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.IsEqualSignature(System.String,System.Int32)">
            <summary>Проверка на эквивалентность сигнатуре</summary>
            <param name="sName">Имя функции</param>
            <param name="ArgumentsCount">Количество аргументов</param>
            <returns>Истина, если сигнатура соответствует функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.IsEqualSignature(System.String,System.String[])">
            <summary>Проверка на эквивалентность сигнатуре</summary>
            <param name="sName">Имя функции</param>
            <param name="Arguments">Массив имён аргументов</param>
            <returns>Истина, если сигнатура соответствует функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.GetValue">
            <summary>Метод получения значения функции. В общем виде не поддерживается.</summary>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.Clone">
            <summary>Клонирование функции</summary>
            <returns>Клон функции</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionItem">
            <summary>Элемент математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionItem.Name">
            <summary>Имя</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionItem.#ctor">
            <summary>Инициализация нового элемента математического выражения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionItem.#ctor(System.String)">
            <summary>Инициализация нового элемента математического выражения</summary>
            <param name="Name">Имя элемента</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionItem.GetValue">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionOperator">
            <summary>Оператор</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionOperator.GetValue">
            <summary>Получить значение</summary>
            <returns>Значение оператора</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode">
            <summary>Узел дерева выражений, реализующий оператор сложения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.#ctor">
            <summary>Новый оператор сложения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compute">
            <summary>Вычисление узла</summary>
            <returns>Сумма поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Linq.Expression.Add()</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Linq.Expression.Add()</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Полный клон узла с клонами поддеревьев</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор ленивого И</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора ленивого И</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию И</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию И</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.CharNode">
            <summary>Символьный узел дерева математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.CharNode.Value">
            <summary>Значение символа узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.#ctor">
            <summary>Инициализация нового строкового узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.#ctor(System.Char)">
            <summary>Инициализация нового строкового узла</summary>
            <param name="value">Значение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.op_Implicit(System.Char)~MathService.MathParser.ExpressionTrees.Nodes.CharNode">
            <summary>Оператор неявного преобразования строки к типу строкового узла</summary>
            <param name="value">Строковое значение</param>
            <returns>Символьный узел</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.op_Implicit(MathService.MathParser.ExpressionTrees.Nodes.CharNode)~System.Char">
            <summary>Оператор неявного преобразования строкового узла к символьному типу</summary>
            <param name="node">Символьный узел</param>
            <returns>Значение Символьного узла</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Name">
            <summary>Имя узла</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.f_ParametersExpression">
            <summary>Выражение параметров</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.f_CoreExpression">
            <summary>Выражение ядра функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Parameters">
            <summary>Выражение параметров</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Core">
            <summary>Выражение ядра функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Operator">
            <summary>Оператор</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode">
            <summary>Узел дерева мат.выражения, реализующий скобки с возможностью вычисления</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.f_Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.#ctor(MathService.MathParser.Bracket,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Вычислимыый блочный узел дерева</summary>
            <param name="bracket">Скобки</param>
            <param name="Node">Узел-содержимое</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compute">
            <summary>Вычислить значение узла</summary>
            <returns>Значение вложенного узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Компиляция содержимого узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла с параметрами</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Компиляция вложенного узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Clone">
            <summary>Клон узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ComputedNode">
            <summary>Вычислимый узел дерева математического выражения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode">
            <summary>Узел дерева, хранящий константное значение</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.f_Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.IsPrecomputable">
            <summary>Флаг возможности получения значения без выччисления. Всегда = true</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Value">
            <summary>Значение узла. Не поддерживает присвоение</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor">
            <summary>Инициализация константного узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor(System.Double)">
            <summary>Инициализация константного узла</summary>
            <param name="Value">Значение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor(System.Int32)">
            <summary>Инициализация константного узла</summary>
            <param name="Value">Значение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор деления</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.#ctor">
            <summary>Инициализация узла оператора деления</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла с параметрами</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Clone">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор равенства</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.GetAbsMethodCall(System.Linq.Expressions.Expression)">
            <summary>Получить выражение вызова метода определения модуля числа из класса Math</summary>
            <param name="x">Параметр выражения</param>
            <returns>Выражение Linq.Expression, Вызывающее метод Math.Abs с параметром x</returns>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.sf_Epsilon">
            <summary>Точность вычисления равенства для чисел с плавающей точкой</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Epsilon">
            <summary>Точность вычисления равенства для чисел с плавающей точкой</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора равенства</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора равенства</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Равенство</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Равенство</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode">
            <summary>Узел дерева вычислений</summary>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator">
            <summary>Перечислитель предков узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.Node">
            <summary>Исходный узел</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.Item(System.Int32)">
            <summary>Итератор предков узла, где узел с индексом 0 - первый предок узла</summary>
            <param name="i">Номер предка</param>
            <returns>Предок указанного поколения</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Новый итератор предков узла</summary>
            <param name="Node">Обрабатываемый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.System#Collections#Generic#IEnumerable{MathService#MathParser#ExpressionTrees#Nodes#ExpressionTreeNode}#GetEnumerator">
            <summary>Получить перечислитель предков узла</summary>
            <returns>Перечислитель предков узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель</summary>
            <returns>Перечислитель</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.GetParrentsEnumerable">
            <summary>Метод получения перечисления предков узла</summary>
            <returns>Перечисление предков узла</returns>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.f_Left">
            <summary>Узел левого поддерева</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.f_Right">
            <summary> Узел правого поддерева</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsPrecomputable">
            <summary>Признак возможности получения тревиального значения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsRoot">
            <summary>Является ли узел дерева корнем?</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsLeftSubtree">
            <summary>Признак - является ли текущий узел левым поддеревом</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsRightSubtree">
            <summary>Признак - является ли текущий узел правым поддеревом</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Parent">
            <summary>Ссылка на предка узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Left">
            <summary>Левое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Right">
            <summary>Правое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.RightNodes">
            <summary>Перечисление правых узлов правого поддерева включая корень</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LeftNodes">
            <summary>Перечисление левых узлов левого поддерева включая корень</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Parents">
            <summary>Перечислитель предков узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Root">
            <summary>Ссылка на корень дерева</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Depth">
            <summary>Глубина положения узла в дереве</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LastLeftChild">
            <summary>Самый левый дочерний узел, либо текущий</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LastRightChild">
            <summary>Самый правый дочерний узел, либо текущий</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.String)">
            <summary>Доступ к элементам узла по указанному пути</summary>
            <param name="Path">Путь к элементам узла Пример:.\.\l\r\r\l  ..\l\r\r</param>
            <returns>Элемент узла, выбранный по указанному пути</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.Func{MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary>Доступ к дочерним элементам узла с помощью метода выбора</summary>
            <param name="ChildSelector">Метод выбора элементов узла</param>
            <returns>Перечисление дочерних элементов по указанному методу</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.Func{MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary> Итератор элементов узла методом выборки</summary>
            <param name="Selector">Метод выбборки узлов относительно текущего</param>
            <returns>Перечисление узлов по указанному методу</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Path">
            <summary>Путь к узлу</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Bypassing(MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType)">
            <summary>Метод обхода дерева</summary>
            <param name="type">Тип обхода дерева</param>
            <returns>Перечисление элементов дерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetChilds">
            <summary>Перечисление дочерних элементов дерева</summary>
            <returns>Перечисление дочерних элементов дерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.SwapToChild(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Поменять узел местами с дочерним</summary>
            <param name="Parent">Материнский узел</param>
            <param name="Child">Дочерний узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Swap(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Подменить узел А узлом В</summary>
            <param name="A">Замещаемый узел</param>
            <param name="B">Подменяемый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.SwapTo(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Заменить узел на указанный</summary>
            <param name="Node">Ухел, на который производится замена</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Remove">
            <summary>Удалить узел с перекоммутацией ссылок</summary>
            <returns>Если удаляется корень, то левое поддерево, иначе ссылка не предка узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetNextLeft">
            <summary>Получить следующий узел слева</summary>
            <returns>Узел слева от текущего</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetNextRight">
            <summary>Получить следующий узел справа</summary>
            <returns>Узел справа от текущего</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetVariables">
            <summary>Перечисление переменных, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева переменных</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetFunctions">
            <summary>Перечисление функций, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева функций</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetFunctionals">
            <summary>Перечисление функционалов, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева функционалов</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Dispose">
            <summary>Уничтожить узел рекурентно с поддеревьями</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.System#ICloneable#Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.op_Implicit(System.String)~MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode">
            <summary>Оператор неявного преобразования строки в узел дерева</summary>
            <param name="value">Строковое значение</param>
            <returns>Строковый узел дерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode">
            <summary>Узел дерева выражения, содержащий сведенья об аргументе функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.ArgumentNode">
            <summary>Узел аргумента</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.ArgumentName">
            <summary>Узел имени аргумента</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor(System.String,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
            <param name="Name">Имя</param>
            <param name="Expression">Узел выражения аргумента</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.StringNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
            <param name="Name">Имя</param>
            <param name="Expression">Выражение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compute">
            <summary>Метод вычисления значения узла</summary>
            <returns>Значение аргумента</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compile">
            <summary>Компиляция узла аргумента</summary>
            <returns>Скомпилированное выражение</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла аргумента с учётом списка параметров</summary>
            <param name="Parameters">Массив параметров процесса компиляции</param>
            <returns>Скомпилированное значение узла аргумента дерева выражения</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode">
            <summary>Узел дерева мат.выражения, хранящий данные об аргументе функции</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.EnumArguments(MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode)">
            <summary>Перечисление аргументов начиная с указанного</summary>
            <param name="Node">Первый узел аргумента</param>
            <returns>Перечисление пар имени-корня дерева аргумента</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.ArgumentSubtree">
            <summary>Значение аргумента - правое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.ArgumentName">
            <summary>Имя аргумента - левое поддерево</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor">
            <summary>Инициализация узла-аргумента</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor(System.String,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла-аргумента</summary>
            <param name="Name">Имя аргумента</param>
            <param name="Node">Узел поддерева аргумента</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode)">
            <summary>Инициализация узла-аргумента</summary>
            <param name="Node">Узел поддерева аргумента</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compile">
            <summary>Компиляция узла аргумента</summary>
            <returns>Скомпилированное выражение корня поддерева аргумента</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла аргумента</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение корня поддерева аргумента</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клонирование узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode">
            <summary>Узел дерева выражения, содержащий функцию</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Name">
            <summary>Имя функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.ArgumentsNames">
            <summary>Массив имён аргументов функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Arguments">
            <summary>Перечисление аргументов функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Function">
            <summary>Функция узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor">
            <summary>Инициализация нового функционального узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(System.String)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.StringNode)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(MathService.MathParser.FunctionTerm,MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Term">Выражение функции</param>
            <param name="Parser">Парсер выражения</param>
            <param name="Expression">Математическое выражение</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.GetFunctionArgumentNodes(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Получить перечисление аргументов функции</summary>
            <param name="FunctionNode">Узел функции</param>
            <returns>Перечисление аргументов функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор больше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора больше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора больше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x больше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Больше</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Больше</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор меньше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора меньше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора меньше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Меньше</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Меньше</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий логическую операцию</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее логику оператора</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее логику оператора</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор умножения "*"</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора произведения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора произведения</summary>
            <param name="Left">Левое поддерево произведения</param>
            <param name="Right">Правое поддерево произведения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Произведение значений корней правого и левого поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор отрицания</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора меньше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора меньше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод отрицания</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.ComparerSingle(System.Double)">
            <summary>Метод отрицания</summary>
            <param name="x">Значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию отрицания НЕ</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию отрицания НЕ</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode">
            <summary>Узел деерва мат.выражения, реализующий оператор</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.IsPrecomputable">
            <summary>Оператор является предвычислимым если предвычислимы его правое и левое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.Priority">
            <summary>Приоритет оператора</summary>
            <remarks>
            Чем выше приоритет, тем глубже в дереве должен находиться оператор
            Шакала базовых приоритетов:
             + - 0
             - - 5
             * - 10
             / - 15
             ^ - 20
            </remarks>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.Name">
            <summary>Ипя оператора</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor">
            <summary>Инициализация оператора</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor(System.String)">
            <summary>Инициализация оператора</summary>
            <param name="Name">Имя оператора</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor(System.String,System.Int32)">
            <summary>Инициализация оператора</summary>
            <param name="Name">Имя оператора</param>
            <param name="Priority">Приоритет оператора</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор ленивого ИЛИ</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора ленивого ИЛИ</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию ИЛИ</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию ИЛИ</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode">
            <summary>Узел дерева математического выражения, реализующий оператор возведения в степень</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора возведения в степень</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compute">
            <summary>Вычисление узла выражения</summary>
            <returns>Возведение значения корня левого поддерева в степень значения корня правого поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compile">
            <summary>Компиляция выражения узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция выражения узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор выбора</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора выбора</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора выбора</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode">
            <summary>Узел дерева выражения, релизующий оператор вычитания</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.#ctor">
            <summary>Инициализация нового оператора вычитания</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.Compute">
            <summary>Вычисление значение узла</summary>
            <returns>Значение разности значений правого и левого поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.Compile">
            <summary>Компиляция выражения узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция выражения узла</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
            <returns></returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ValueNode">
            <summary>Узел дерева мат.выражения, хранящий значение</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ValueNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ValueNode.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode">
            <summary>Узел дерева, хранящий переменную</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.IsPrecomputable">
            <summary>Признак возможности получения тревиального значения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Variable">
            <summary>Ссылка на переменную</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Name">
            <summary>Имя переменной</summary> 
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.#ctor(MathService.MathParser.ExpressionVariabel)">
            <summary>Новый узел переменной</summary>
            <param name="Variable">Переменная</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор определения вариантов</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора определения вариантов</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора определения вариантов</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode">
            <summary>Узел интервального значения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ParsedNode">
            <summary>Узел дерева выражения стадии разбора</summary>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.StringNode">
            <summary>Строковый узел дерева математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.StringNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.#ctor">
            <summary>Инициализация нового строкового узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.#ctor(System.String)">
            <summary>Инициализация нового строкового узла</summary>
            <param name="value">Значение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.op_Implicit(System.String)~MathService.MathParser.ExpressionTrees.Nodes.StringNode">
            <summary>Оператор неявного преобразования строки к типу строкового узла</summary>
            <param name="value">Строковое значение</param>
            <returns>Строковый узел</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.op_Implicit(MathService.MathParser.ExpressionTrees.Nodes.StringNode)~System.String">
            <summary>Оператор неявного преобразования строкового узла к строковому типу</summary>
            <param name="node">Строковый узел</param>
            <returns>Значение строкового узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.ExpressionTree">
            <summary>Дерево выражения</summary>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType">
            <summary>Метод обхода дерева</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.LeftRightRoot">
            <summary>Левое поддерево, правое подерево, корень</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.LeftRootRight">
            <summary>Левое поддерево, корень, правое поддерево</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RootLeftRight">
            <summary>Корень, левое поддерево, правое поддерево</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RightLeftRoot">
            <summary>Правое поддерево, левое поддерево, корень</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RightRootLeft">
            <summary>Правое поддерево, корень, левое поддерево</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RootRightLeft">
            <summary>Корень, правое поддерево, левое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.ExpressionTree.Root">
            <summary>Корень</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.#ctor">
            <summary>Инициализация нового дерева математического выражения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового дерева математического выражения</summary>
            <param name="Root">Узел - корень дерева</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Clear">
            <summary>Очистить дерево</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Remove(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Удалить узел</summary>
            <param name="Node">Удаляемый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Swap(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Заменить узел</summary>
            <param name="OldNode">Исходный узел</param>
            <param name="NewNode">Новый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.MoveParentDown(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Переместить узел вниз</summary>
            <param name="Node">Перемещаемый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Bypass(MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType)">
            <summary>Обойти дерево</summary>
            <param name="type">Способ обхода</param>
            <returns>Перечисление узлов дерева по указанному способу обхода</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Dispose">
            <summary>Уничтожить дерево</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.ToString">
            <summary>
            Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.
            </summary>
            <returns>
            Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Clone">
            <summary>Клонировать дерево</summary>
            <returns>Клон дерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.System#ICloneable#Clone">
            <summary>Клонировать дерево</summary>
            <returns>Клон дерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.GetEnumerator">
            <summary>Получить перечислитель узлов дерева по методу ЛКП</summary>
            <returns>Перечислитель узлов дерева по методу ЛКП</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionParser">
            <summary>Парсер математических выражений</summary>
        </member>
        <member name="E:MathService.MathParser.ExpressionParser.NewNodeAdded">
            <summary>Событие возникает при добавлении нового узла в дерево выражения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnNewNodeAdded(System.EventArgs{MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary>При добавлении нового узла в дерево выражения</summary>
            <param name="e">Аргумент события, содержащий добавляемй узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnNewNodeAdded(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@)">
            <summary>Обработка очередного добавляемого в дерево узла</summary>
            <param name="NewNode">Новый добавляемый узел дерева выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.ProcessNewNode(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@)">
            <summary>Обработка нового узла дерева выражения</summary>
            <param name="NewNode">Новый добавляемый узел</param>
        </member>
        <member name="E:MathService.MathParser.ExpressionParser.StringPreprocessing">
            <summary>Событие предобработки входящей строки</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnStringPreprocessing(System.EventArgs{System.String})">
            <summary>Генерация события предобработки входящей строки</summary>
            <param name="args">Аргумент события, содержащий обрабатываемую строку</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnStringPreprocessing(System.String@)">
            <summary>Генерация события предобработки входящей строки</summary>
            <param name="StrExpression">Обрабатываемая строка</param>
        </member>
        <member name="T:MathService.MathParser.ExpressionParser.FindFunctionEventArgs">
            <summary>Аргумент события обнаружения функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.Name">
            <summary>Имя обнаруженой функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.Arguments">
            <summary>Массив имён аргументов функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.ArgumentCount">
            <summary>Количество аргументов функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.Function">
            <summary>Делегат функции, который надо использовать при её вычислении</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.#ctor(System.String,System.String[])">
            <summary>Инициализация аргумента события обнаружения функции</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Массив имён аргументов функции</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.SignatureEqual(System.String,System.Int32)">
            <summary>Проверка на совпадение сигнатуры функции по имени и числу переменных</summary>
            <param name="name">Имя проверяемой функции</param>
            <param name="ArgumentsCount">Число переменных</param>
            <returns></returns>
        </member>
        <member name="E:MathService.MathParser.ExpressionParser.FindFunction">
            <summary>Событие, возникающее в процессе разбора математического выражения при обнаружении функции</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnFindFunction(MathService.MathParser.ExpressionParser.FindFunctionEventArgs)">
            <summary>Обработчик события обнаружения функции в процессе разбора выражения</summary>
            <param name="Args">Аргументы события, содержащие имя функции, имена аргументов и делегат метода функции</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnFunctionFind(System.String,System.String[])">
            <summary>Обработчик события обнаружения функции в процессе разбора выражения</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Аргументы функции</param>
            <returns>Делегат функции</returns>
        </member>
        <member name="E:MathService.MathParser.ExpressionParser.VariableProcessing">
            <summary>Событие обработки переменных при разборе мат.выражений</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnVariableProcessing(System.EventArgs{MathService.MathParser.ExpressionVariabel})">
            <summary> Обработка обнаруженной переменной</summary>
            <param name="e">Обнаруженная переменная</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnVariableProcessing(MathService.MathParser.ExpressionVariabel)">
            <summary> Обработка обнаруженной переменной</summary>
            <param name="Variable">Обнаруженная переменная</param>
        </member>
        <member name="F:MathService.MathParser.ExpressionParser.f_ExcludeCharsSet">
            <summary>Множество запрещённых символов</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionParser.f_Constans">
            <summary>Словарь констант</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.ExcludeCharsSet">
            <summary>Множество запрещённых симовлов</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.ExpressionSeparator">
            <summary>Разделитель выражений (по умолчанию ';')</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.DecimalSeparator">
            <summary>Разделитель целой части и мантисы десятичного числа</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.Constants">
            <summary>Константы</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.#ctor">
            <summary>Парсер математических выражений</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.StrPreprocessing(System.String@)">
            <summary>Предварительная обработка входного строкового выражения</summary>
            <param name="Str">Обрабатываемая строка</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.Parse(System.String)">
            <summary>Разобрать строку математического выражения</summary>
            <param name="StrExpression">Строковое представление математического выражения</param>
            <returns>Математическое выражение</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.ProcessVariables(MathService.MathParser.MathExpression)">
            <summary>Обработка переменных</summary>
            <param name="Expression">Обрабатываемое математическое выражение</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.ProcessFunctions(MathService.MathParser.MathExpression)">
            <summary>Обработка функций</summary>
            <param name="Expression">Обрабатываемое математическое выражение</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.GetOperatorNode(System.Char)">
            <summary>Метод определения узла дерева, реализующего оператор</summary>
            <param name="Name">Имя оператора</param>
            <returns>Узел дерева оператора</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.GetFunctional(System.String)">
            <summary>Метод определения функционала по имени</summary>
            <param name="Name">Имя функционала</param>
            <returns>Функционал</returns>
            <exception cref="T:System.NotSupportedException">Возникает для неопределённых имён функционалов</exception>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.GetRoot(MathService.MathParser.Term[],MathService.MathParser.MathExpression)">
            <summary>Метод излвечения корня дерева из последовательности элементов математического выражения</summary>
            <param name="Group">группа элементов математического выражения</param>
            <param name="MathExpression">Ссылка на математическое выражение</param>
            <returns>Корень дерева мат.выражения</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.Combine(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Комбинация предыдущего и текущего узлов дерева</summary>
            <param name="Last">Предыдущий узел дерева (уже интегрированный в дерево)</param>
            <param name="Node">Текущий узел, который надо вставить в дерево</param>
        </member>
        <member name="T:MathService.MathParser.ExpressionVariabel">
            <summary>Переменная математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionVariabel.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionVariabel.IsPrecomputable">
            <summary>Признак возможности предвычисления значения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionVariabel.IsConstant">
            <summary>Является ли константой?</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.GetValue">
            <summary>Метод извлечения значения</summary>
            <returns>Численное значение переменной</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.#ctor(System.String)">
            <summary>Инициализация нового экземпляра переменной</summary>
            <param name="Name">Имя переменной</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.Clone">
            <summary>Клонирование переменной</summary>
            <returns>Новый экземпляр переменной с тем же имененм и тем же значением</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление переменной</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.op_Implicit(System.Double)~MathService.MathParser.ExpressionVariabel">
            <summary>Оператор неявного привидения вещественного числа к типу переменной</summary>
            <param name="x">Вещественное число</param>
            <returns>Безымянная переменная, хранящая указанное число</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.op_Implicit(MathService.MathParser.ExpressionVariabel)~System.Double">
            <summary>Оператор неявного привидения к типу вещественного числа</summary>
            <param name="variable">Приводимая переменная</param>
            <returns>Значение переменной</returns>
        </member>
        <member name="T:MathService.MathParser.FunctionsCollection">
            <summary>Коллекция функций</summary>
        </member>
        <member name="F:MathService.MathParser.FunctionsCollection.f_MathExpression">
            <summary>Ссылка на математическое выражение</summary>
        </member>
        <member name="F:MathService.MathParser.FunctionsCollection.f_Functions">
            <summary>Список функций математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionsCollection.Names">
            <summary>Имена функций</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionsCollection.Count">
            <summary>Количество используемых функций</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionsCollection.Item(System.String,System.Int32)">
            <summary>Индексатор функций по имени и списку параметров</summary>
            <param name="Name">Имя функции</param>
            <param name="ArgumentsCount">Количество аргументов</param>
            <returns>Функция, удовлетворяющаяя заданой сигнатуре</returns>
        </member>
        <member name="P:MathService.MathParser.FunctionsCollection.Item(System.String,System.String[])">
            <summary>Индексатор функций по имени и списку параметров</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Список имён аргументов</param>
            <returns>Функция, удовлетворяющаяя заданой сигнатуре</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionsCollection.#ctor(MathService.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции функций математического выражения</summary>
            <param name="MathExpression">Математическое выражение, на которое ссылается создаваемая коллекция</param>
        </member>
        <member name="M:MathService.MathParser.FunctionsCollection.Add(MathService.MathParser.ExpressionFunction)">
            <summary>Добавить функцию в коллекцию</summary>
            <param name="function">Функция</param>
            <returns>Истина, если функция была добавлена</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionsCollection.System#Collections#Generic#IEnumerable{MathService#MathParser#ExpressionFunction}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:MathService.MathParser.FunctionsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="T:MathService.MathParser.FunctionTerm">
            <summary>Функциональный элемент выражения</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionTerm.Block">
            <summary>Блок со скобками</summary>
        </member>
        <member name="M:MathService.MathParser.FunctionTerm.#ctor(MathService.MathParser.StringTerm,MathService.MathParser.BlockTerm)">
            <summary>Новый функциональный элемент выражения</summary>
            <param name="StrTerm">Строковый элемент выражения</param>
            <param name="Block">Блок выражения</param>
        </member>
        <member name="M:MathService.MathParser.FunctionTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Получить поддерево</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел функции</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionTerm.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление элемента</returns>
        </member>
        <member name="T:MathService.MathParser.IntegralOperator">
            <summary>Комплексный оператор интегрирования</summary>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.#ctor">
            <summary>Создание нового комплексного интегритора интегрирования</summary>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.#ctor(System.String)">
            <summary>Создание нового комплексного интегритора интегрирования</summary>
            <param name="Name">Имя оператора</param>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.Initialize(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер</param>
            <param name="Expression">Внешнее выражение</param>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.GetValue(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathService.MathParser.IntegralOperator.AdaptiveIntegralDelegate">
            <summary>Делегат адаптивного интегрирования</summary>
            <param name="d">Делегат интегрируемой функци</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Коненое значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.GetAdaptiveIntegral(System.Delegate,System.Double,System.Double,System.Double[])">
            <summary>Получить численное значение интеграла адаптивным методом</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Коненое значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="T:MathService.MathParser.IntegralOperator.IntegralDelegate">
            <summary>Получить численное значение интеграла методом трапеций</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Коненое значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <param name="dx">Шаг интерирования</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.GetIntegral(System.Delegate,System.Double,System.Double,System.Double[],System.Double)">
            <summary>Получить численное значение интеграла методом трапеций</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Коненое значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <param name="dx">Шаг интерирования</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Ядро функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="T:MathService.MathParser.LamdaExpressionVariable">
            <summary>Лямда-переменная</summary>
            <remarks>Значение переменной - результат вычисления лямда-функции</remarks>
        </member>
        <member name="F:MathService.MathParser.LamdaExpressionVariable.f_Value">
            <summary>Функция вычисления значения переменной</summary>
        </member>
        <member name="P:MathService.MathParser.LamdaExpressionVariable.IsPrecomputable">
            <summary>Признак отсутствия возможности предвычисления значения</summary>
        </member>
        <member name="M:MathService.MathParser.LamdaExpressionVariable.#ctor(System.Func{System.Double})">
            <summary>Инициализация нового экземпляра лямда-переменной</summary>
            <param name="Source">Лямда-функция получения значения переменной</param>
        </member>
        <member name="M:MathService.MathParser.LamdaExpressionVariable.#ctor(System.String,System.Func{System.Double})">
            <summary>Инициализация нового экземпляра лямда-переменной</summary>
            <param name="Name">Имя переменной</param>
            <param name="Source">Лямда-функция получения значения переменной</param>
        </member>
        <member name="M:MathService.MathParser.LamdaExpressionVariable.GetValue">
            <summary>Получить значение переменной</summary>
            <returns>Численное значение переменной</returns>
        </member>
        <member name="M:MathService.MathParser.LamdaExpressionVariable.Clone">
            <summary>Клонировать переменную</summary>
            <returns>Новый экземпляр лямда-переменной с тем же именем и клоном функции</returns>
        </member>
        <member name="T:MathService.MathParser.MathExpression">
            <summary>Математическое выражение</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression.f_ExpressionTree">
            <summary>Дерево математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression.f_Variables">
            <summary>Коллекция переменных математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression.f_Constants">
            <summary>Коллекция констант математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression.f_Functions">
            <summary>Коллекция функций, учавствующих в выражении</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression.f_Functionals">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression.f_Name">
            <summary>Имя выражения</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Name">
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value"/> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException" accessor="set">Указано пустое имя функции</exception>
        </member>
        <member name="P:MathService.MathParser.MathExpression.IsPrecomputable">
            <summary>Является ли выражение предвычислимым?</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Tree">
            <summary>Дерево математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Variable">
            <summary>Переменные, входящие в математическое выражение</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Constants">
            <summary>Константы, входящие в математическое выражение</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Functions">
            <summary>Коллекция функций, учавствующих в выражении</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Functionals">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="M:MathService.MathParser.MathExpression.#ctor(System.String)">
            <summary>Инициализация пустого математического выражения</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathService.MathParser.MathExpression.#ctor(MathService.MathParser.ExpressionTrees.ExpressionTree,System.String)">
            <summary>Инициализация нового математического выражения</summary>
            <param name="Tree">Дерево математического выражения</param>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathService.MathParser.MathExpression.#ctor(System.String,MathService.MathParser.ExpressionParser)">
            <summary>Инициализация нового математического выражения</summary>
            <param name="StrExpression">Строковое представление выражения</param>
            <param name="Parser">Ссылка на парсер</param>
        </member>
        <member name="M:MathService.MathParser.MathExpression.System#IDisposable#Dispose">
            <summary>Уничтожить математическое выражение</summary>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compute">
            <summary>Вычисление математического выражения</summary>
            <returns>Значение выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compute(System.Double[])">
            <summary>Вычисление математического выражения</summary>
            <returns>Значение выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile">
            <summary>Компиляция математического выражения в функцию без параметров</summary>
            <returns>Функция типа double func(void) без параметров</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile1">
            <summary>Компиляция функции одной переменной</summary>
            <returns>Делегат функции одной переменной</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile2">
            <summary>Компиляция функции двух переменных</summary>
            <returns>Делегат функции двух переменных</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile3">
            <summary>Компиляция функции трёх переменных</summary>
            <returns>Делегат функции трёх переменных</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile(System.String[])">
            <summary>Компиляция математического выражения в функцию указанного типа</summary>
            <param name="ArgumentName">Список имён параметров</param>
            <returns>Делегат скомпелированного выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.CompileMultyParameters(System.String[])">
            <summary>Многопараметрическая компиляия мат.выражения</summary>
            <param name="ArgumentName">Массив имён компилируемых параметров</param>
            <returns>Делегат функции, принимающий на вход массив значений параметров</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile``1(System.String[])">
            <summary>Компиляция математического выражения в функцию указанного типа</summary>
            <typeparam name="TDelegate">Тип делегата функции</typeparam>
            <param name="ArgumentName">Список имён параметров</param>
            <returns>Делегат скомпелированного выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.GetExpression(System.Linq.Expressions.ParameterExpression[]@,System.String[])">
            <summary>Получить Linq.Expression выражение, построенное на основе дерева выражений</summary>
            <param name="vars">Список входных переменных</param>
            <param name="ArgumentName">Список имён аргументов</param>
            <returns>Выражение типа Linq.Expression</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.GetExpression``1(System.Linq.Expressions.ParameterExpression[]@,System.String[])">
            <summary>Получить Linq.Expression выражение, построенное на основе дерева выражений</summary>
            <typeparam name="TDelegate">Тип делегата выражения</typeparam>
            <param name="vars">Список входных переменных</param>
            <param name="ArgumentName">Список имён аргументов</param>
            <returns>Выражение типа Linq.Expression</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.CheckConstatnsCollection(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Перенос констант из выражения источника в выражение приёмник</summary>
            <param name="Source">Выражение источник</param>
            <param name="Result">Выражение приёмник</param>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Clone">
            <summary>Клонирование выражения</summary>
            <returns>Копия объектной модели выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.System#ICloneable#Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.MathParser.MathExpression.CombineExpressions(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,MathService.MathParser.ExpressionTrees.Nodes.OperatorNode)">
            <summary>Комбинация двух выражений с использованием узла-оператора</summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="node">Узел операции</param>
            <returns>Математическое выражение, в корне дерева которого лежит узел оператора. Поддеревья - корни первого и второго выражений</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Addition(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор сложения двух выражений</summary>
            <param name="x">Первое слогаемое</param>
            <param name="y">Второе слогаемое</param>
            <returns>Выражение-сумма, корень которого - узел суммы. Поддеревья - корни выражений слогаемых</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Subtraction(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор вычитания двух выражений</summary>
            <param name="x">Уменьшаемое</param>
            <param name="y">Вычитаемое</param>
            <returns>Выражение-разность, корень которого - узел разности. Поддеревья - корни выражений вычитаемого и уменьшаемого</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Multiply(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор умножения двух выражений</summary>
            <param name="x">Первый сомножитель</param>
            <param name="y">Второй сомножитель</param>
            <returns>Выражение-произведения, корень которого - узел произведения. Поддеревья - корни выражений сомножителей</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Division(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор деления двух выражений</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Выражение-частное, корень которого - узел деления. Поддеревья - корни выражений делимого и делителя</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_ExclusiveOr(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор возведения в степень</summary>
            <param name="x">Основание</param>
            <param name="y">Показатель степени</param>
            <returns>Выражение-степень, корень которого - узел степени. Поддеревья - корни выражений Основания и показателя степени</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Implicit(MathService.MathParser.MathExpression)~MathService.MathParser.ExpressionTrees.ExpressionTree">
            <summary>Оператор неявного приведения типов математического выражения к типу дерева выражения</summary>
            <param name="Expression">Математическое выражение</param>
            <returns>Дерево математического выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Implicit(MathService.MathParser.ExpressionTrees.ExpressionTree)~MathService.MathParser.MathExpression">
            <summary>Оператор неявного приведения типов дерева выражения к типу математического выражения</summary>
            <param name="Tree">Дерево математического выражения</param>
            <returns>Математическое выражение, содержащее указанное дерево</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Implicit(MathService.MathParser.MathExpression)~System.Func{System.Double}">
            <summary>Оператор неявного приведения типов математического выражения к типу делегата функции double Func(void)</summary>
            <param name="expr">Математическое выражения</param>
            <returns>Результат компиляции математического выражения</returns>
        </member>
        <member name="T:MathService.MathParser.NumberTerm">
            <summary>Числовой элемент математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.NumberTerm.f_IntValue">
            <summary>Численное значение элемента</summary>
        </member>
        <member name="P:MathService.MathParser.NumberTerm.Value">
            <summary>Численное значение элемента</summary>
        </member>
        <member name="M:MathService.MathParser.NumberTerm.#ctor(System.String)">
            <summary>Новый численный элемент мат.выражения</summary>
            <param name="Str">Строковое значение элемента</param>
        </member>
        <member name="M:MathService.MathParser.NumberTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Извлеч поддерево</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел константного значения</returns>
        </member>
        <member name="M:MathService.MathParser.NumberTerm.TryAddFractionPart(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@,MathService.MathParser.Term,System.Char,MathService.MathParser.Term)">
            <summary>Попытаться добавить дробное значение числа</summary>
            <param name="node">Узел выражения</param>
            <param name="SeparatorTerm">Блок разделитель</param>
            <param name="DecimalSeparator">Блок с целой частью числа</param>
            <param name="FrationPartTerm">Блок с дробной частью числа</param>
            <returns>Истина, если действие совершено успешно. Ложь, если в последующих блоках не содержится нужной информации</returns>
        </member>
        <member name="T:MathService.MathParser.StringTerm">
            <summary>Строковый элемент выражения</summary>
        </member>
        <member name="P:MathService.MathParser.StringTerm.Name">
            <summary>Имя строкового элемента</summary>
        </member>
        <member name="M:MathService.MathParser.StringTerm.#ctor(System.String)">
            <summary>Новый строковый элемент</summary>
            <param name="Name">Имя строкового элемента</param>
        </member>
        <member name="M:MathService.MathParser.StringTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Поддерево элемента, состоящее из узла-переменной</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел дерева с переменной, полученной из Expression.Variable[Name]</returns>
        </member>
        <member name="T:MathService.MathParser.SummOperator">
            <summary>Оператор суммы</summary>
        </member>
        <member name="M:MathService.MathParser.SummOperator.#ctor">
            <summary>Инициализация нового оператора суммы</summary>
        </member>
        <member name="M:MathService.MathParser.SummOperator.#ctor(System.String)">
            <summary>Инициализация нового обператора суммы</summary>
            <param name="Name"></param>
        </member>
        <member name="M:MathService.MathParser.SummOperator.Initialize(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Внешнее мат.выражение</param>
        </member>
        <member name="M:MathService.MathParser.SummOperator.GetValue(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathService.MathParser.SummOperator.SummDelegate">
            <summary>Метд суммирования</summary>
            <param name="d">Суммируемая функция - ядро</param>
            <param name="Min">Начало интервала</param>
            <param name="Max">Конец интервала</param>
            <param name="Parameters">Массив параметров функции</param>
            <returns>Значение суммы функции</returns>
        </member>
        <member name="M:MathService.MathParser.SummOperator.GetSumm(System.Delegate,System.Double,System.Double,System.Double[])">
            <summary>Получение значения суммы</summary>
            <param name="d">Суммируемая функция - ядро</param>
            <param name="Min">Начало интервала суммирования</param>
            <param name="Max">Конец интервала суммирования</param>
            <param name="Parameters">Массив параметров</param>
            <returns>Сумма функции</returns>
        </member>
        <member name="M:MathService.MathParser.SummOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <param name="ParametersExpression">Выражение блока параметров</param>
            <param name="Function">Выражение блока ядра оператора - функции</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.SummOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Ядро функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="T:MathService.MathParser.Term">
            <summary>Элемент математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.Term.f_Value">
            <summary>Строковое содержимое</summary>
        </member>
        <member name="M:MathService.MathParser.Term.#ctor(System.String)">
            <summary>Конструктор элемента математического выражения</summary>
            <param name="Value">Строковое содержимое</param>
        </member>
        <member name="M:MathService.MathParser.Term.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Метод извлечения поддерева для данного элемента математического выражения</summary>
            <param name="Parser">Парсер математического выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел дерева мат.выражения, являющийся поддеревом для данного элемента мат.выражения</returns>
        </member>
        <member name="M:MathService.MathParser.Term.ToString">
            <summary>Строковое представление элемента мат.выражения</summary>
            <returns>Строковое содержимое элемета мат.выражения</returns>
        </member>
        <member name="T:MathService.MathParser.VariabelsCollection">
            <summary>Коллекция переменных</summary>
        </member>
        <member name="F:MathService.MathParser.VariabelsCollection.f_Expression">
            <summary>Математическое выражение</summary>
        </member>
        <member name="P:MathService.MathParser.VariabelsCollection.Count">
            <summary>Количество переменных в коллекции</summary>
        </member>
        <member name="P:MathService.MathParser.VariabelsCollection.Item(System.String)">
            <summary>Итератор переменных коллекции</summary>
            <param name="Name">Имя переменной</param>
            <returns>Переменная с указанным именем</returns>
        </member>
        <member name="P:MathService.MathParser.VariabelsCollection.Item(System.Int32)">
            <summary>Итератор переменных коллекции</summary>
            <param name="i">Индекс переменной</param>
            <returns>Переменная с указанным индексом</returns>
        </member>
        <member name="P:MathService.MathParser.VariabelsCollection.Names">
            <summary>Перечисление всех имён переменных колеекции</summary>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.#ctor(MathService.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции переменных</summary>
            <param name="expression">Математическое выражение, которому принадлежит коллекция</param>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Add(MathService.MathParser.ExpressionVariabel)">
            <summary>Добавить переменную в коллекцию</summary>
            <param name="Variable">Переменная</param>
            <returns>Истина, если переменная была добавлена</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.MoveToConstCollection(System.String)">
            <summary>Переместить переменную из коллекции переменных в коллекцию констант</summary>
            <param name="Variable">Перемещаемая переменная</param>
            <returns>Истина, если переменная была перемещена из коллекции переменных в коллекцию констант</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.MoveToConstCollection(MathService.MathParser.ExpressionVariabel)">
            <summary>Переместить переменную из коллекции переменных в коллекцию констант</summary>
            <param name="Variable">Перемещаемая переменная</param>
            <returns>Истина, если переменная была перемещена из коллекции переменных в коллекцию констант</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Remove(MathService.MathParser.ExpressionVariabel)">
            <summary>Удаление переменной из коллекции</summary>
            <param name="Variable">Удаляемая переменная</param>
            <returns>Истина, если удаление прошло успешно</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.RemoveFromCollection(MathService.MathParser.ExpressionVariabel)">
            <summary>Удалить переменную из коллекции</summary>
            <param name="Variable">Удаляемая переменная</param>
            <returns>Истина, если переменная удалена успешно</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.ClearCollection">
            <summary>Очистить коллекцию переменных</summary>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Exist(System.String)">
            <summary>Существует ли в коллекции переменная с указанным имененм</summary>
            <param name="Name">Искомое имя переменной</param>
            <returns>Истина, если в коллекции пристутствует переменная с указанным именем</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Exist(MathService.MathParser.ExpressionVariabel)">
            <summary>Проверка на существование переменной в коллекции</summary>
            <param name="variable">Проверяемая переменная</param>
            <returns>Истина, если указанная переменная входит в коллекцию</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Exist(System.Predicate{MathService.MathParser.ExpressionVariabel})">
            <summary>Существует ли переменная в коллекции с заданным критерием поиска</summary>
            <param name="exist">Критерий поиска переменной</param>
            <returns>Истина, если найдена переменная по указанному критерию</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.ExistInTree(System.String)">
            <summary>Существует ли узел переменной в дереве с указанным именем</summary>
            <param name="Name">Искомое имя переменной</param>
            <returns>Истина, если указанное имя переменной существует в дереве</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.ExistInTree(System.Func{MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Существует ли узел переменной в дереве</summary>
            <param name="exist">Критерий поиска</param>
            <returns>Истина, если найден узел по указанному критерию</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodes(System.String)">
            <summary>Получить перечисление узлов переменных с указанным именем</summary>
            <param name="VariableName">Искомое имя переменной</param>
            <returns>Перечисление узлов с переменными с указанным именем</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodes(System.Func{MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Получить перечисление узлов дерева с переменными</summary>
            <param name="selector">Метод выборки узлов</param>
            <returns>Перечисление узлов переменных</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodesOf``1">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodesVOf``1(System.Func{``0,System.Boolean})">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <param name="selector">Метод выбора узлов по содержащимся в них переменным</param>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodesOf``1(System.Func{MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <param name="selector">Метод выбора узлов</param>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.System#Collections#Generic#IEnumerable{MathService#MathParser#ExpressionVariabel}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:MathService.ObjectAnimator.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="M:MathService.CommandStringArguments.GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции аргументов командной строки</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, 
            который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.CommandStringArguments.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, 
            который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.Complex">
            <summary>Комплексное число</summary>
        </member>
        <member name="M:MathService.Complex.op_Addition(MathService.Complex,MathService.Complex)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слогаемое</param>
            <param name="Y">Второе слогаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(MathService.Complex,MathService.Complex)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Addition(System.Double,MathService.Complex)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слогаемое</param>
            <param name="Y">Второе слогаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(System.Double,MathService.Complex)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Addition(MathService.Complex,System.Double)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слогаемое</param>
            <param name="Y">Второе слогаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(MathService.Complex,System.Double)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(MathService.Complex,System.Double)">
            <summary>Оператор умножения комплексного числа на вещественное</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(MathService.Complex,System.Double)">
            <summary>Оператор деления комплексного числа на вещественное</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Вещественный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(System.Double,MathService.Complex)">
            <summary>Оператор произведения вещественного и комплексного числа</summary>
            <param name="X">Вещественное число</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(System.Double,MathService.Complex)">
            <summary>Оператор деления вещественного и комплексного числа</summary>
            <param name="X">Вещественное делимое число</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(MathService.Complex,MathService.Complex)">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(MathService.Complex,MathService.Complex)">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(MathService.Complex,System.Double)">
            <summary>Возведение комплексного числа в вещественную степень по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Вещественный показатель степени Z^X</param>
            <returns>Z^X</returns>       
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(System.Double,MathService.Complex)">
            <summary>Оператор возведения вещественного числа в комплексную степень</summary>
            <param name="X">Вещественное число</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения действистельного числа в комплексную степень</returns>
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(MathService.Complex,MathService.Complex)">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathService.Complex.op_Equality(MathService.Complex,MathService.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathService.Complex.op_Inequality(MathService.Complex,MathService.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathService.Complex.op_Explicit(MathService.Complex)~System.Double">
            <summary>ОПератор неявного приведения к дробному типу чисел с двойной точностью</summary>
            <param name="Z">Приводимое комплексное число</param>
            <returns>Модуль комплексного числа</returns>
        </member>
        <member name="M:MathService.Complex.op_Implicit(System.Double)~MathService.Complex">
            <summary>Оператор неявного приведения дробного числа двойной точности к комплексному виду</summary>
            <param name="X">Вещественное число двойной точности</param>
            <returns>Комплексное число</returns>
        </member>
        <member name="T:MathService.Complex.Trigonomerty">
            <summary>Тригонометрические функции комплексного переменного</summary>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Sin(MathService.Complex)">
            <summary>Синус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Синус комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Cos(MathService.Complex)">
            <summary>Косинус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Косинус комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.tg(MathService.Complex)">
            <summary>Тангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Тангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.ctg(MathService.Complex)">
            <summary>Котангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Котангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.ATan(MathService.Complex)">
            <summary>Арктангенс комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арктангенс комплексного аргумента</returns>
        </member>
        <member name="T:MathService.Complex.Trigonomerty.Hyperbolic">
            <summary>Гиперболические функции</summary>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Hyperbolic.Sh(MathService.Complex)">
            <summary>Гиперболический синус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический синус комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Hyperbolic.Ch(MathService.Complex)">
            <summary>Гиперболический косинус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический косинус комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Hyperbolic.tgh(MathService.Complex)">
            <summary>Гиперболический тангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический тангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Hyperbolic.ctgh(MathService.Complex)">
            <summary>Гиперболический котангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический котангенс комплексного аргумента</returns>
        </member>
        <member name="F:MathService.Complex.Epsilon">
            <summary>Точность вычисления тригонометрических функций 3e-16 </summary>
            <remarks>Определено приближённо</remarks>
        </member>
        <member name="M:MathService.Complex.Sin(MathService.Complex)">
            <summary>Синус комплексного аргумента</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Значение синуса</returns>
        </member>
        <member name="M:MathService.Complex.Cos(MathService.Complex)">
            <summary>Косинус комплексного аргумента</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Значение косинуса</returns>
        </member>
        <member name="M:MathService.Complex.Ln(System.Double)">
            <summary>Логарифм комплексного аргумента</summary>
            <param name="Im">Комплексный аргумент</param>
            <returns>Значение логарифма</returns>
        </member>
        <member name="M:MathService.Complex.Ln(MathService.Complex)">
            <summary>НАтуральный логорифм комплексного числа</summary>
            <param name="z">Комплексное число</param>
            <returns>Натуральный логорифм</returns>
        </member>
        <member name="M:MathService.Complex.Log(System.Double,System.Double)">
            <summary>Логорифм мномого числа по действительному основанию</summary>
            <param name="Im">Мнимое число</param>
            <param name="b">Действительное основание логорифма</param>
            <returns>Логорифм мнимого числа по действительному основанию</returns>
        </member>
        <member name="M:MathService.Complex.Log(MathService.Complex,System.Double)">
            <summary>Логарифм комплексного числа по действительному аргументу</summary>
            <param name="z">Комплексное число</param>
            <param name="b">Действительное основание логорифма</param>
            <returns>Логорифм комплексного числа по действительному основанию</returns>
        </member>
        <member name="M:MathService.Complex.Exp(System.Double)">
            <summary>Экспоненциальная форма числа Z = e^j*Arg</summary>
            <param name="Arg">Аргумент</param>
            <returns>Комплексное число в экспоненциальной форме записи</returns>
        </member>
        <member name="M:MathService.Complex.Exp(System.Double,System.Double)">
            <summary>Экспоненциальная форма числа Z = Abs * e^j*Arg</summary>
            <param name="Abs">Модуль числа</param>
            <param name="Arg">Аргумент числа</param>
            <returns>Комплексное число в экспоненциальной форме</returns>
        </member>
        <member name="M:MathService.Complex.Mod(System.Double,System.Double)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимиая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathService.Complex.Mod(System.Double,MathService.Complex)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимиая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathService.Complex.Mod(MathService.Complex,MathService.Complex)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимиая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathService.Complex.Mod(MathService.Complex,System.Double)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимиая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="F:MathService.Complex.Real">
            <summary>Действительное "комплексное" число</summary>
        </member>
        <member name="F:MathService.Complex.i">
            <summary>Мнимая единица</summary>
        </member>
        <member name="M:MathService.Complex.CreateArray(System.Double[],System.Double[])">
            <summary>Создать массив комплексных чисел</summary>
            <param name="Re">Массив действительных чисел</param>
            <param name="Im">Массив мнимых чисел</param>
            <returns>Массив комплексных чисел</returns>
        </member>
        <member name="F:MathService.Complex.f_Re">
            <summary>Действительная часть</summary>
        </member>
        <member name="F:MathService.Complex.f_Im">
            <summary>Мнимая часть</summary>
        </member>
        <member name="P:MathService.Complex.Expression">
            <summary>Преобразование комплексного числа в выражение</summary>
        </member>
        <member name="P:MathService.Complex.Re">
            <summary>Действительная часть</summary>
        </member>
        <member name="P:MathService.Complex.Im">
            <summary>Мнимая часть</summary>
        </member>
        <member name="P:MathService.Complex.Power">
            <summary>X * X^* = Re(X)^2 + Im(X)^2</summary>
        </member>
        <member name="P:MathService.Complex.Abs">
            <summary>Модуль</summary>
        </member>
        <member name="P:MathService.Complex.Arg">
            <summary>Аргумент</summary>
        </member>
        <member name="P:MathService.Complex.ComplexConjugate">
            <summary>Комплексно сопряжённое число</summary>
        </member>
        <member name="P:MathService.Complex.Reciprocal">
            <summary>Обратное значение 1/Z</summary>
        </member>
        <member name="M:MathService.Complex.#ctor(System.Double,System.Double)">
            <summary>Комплексное число</summary>
            <param name="Re">Действительная часть</param>
            <param name="Im">Мнимая часть</param>
        </member>
        <member name="M:MathService.Complex.ToString">
            <summary>Строковый эквивалент</summary>
            <returns>Строковый эквивалент</returns>
        </member>
        <member name="M:MathService.Complex.ToString(System.String)">
            <summary>Преобразование в строковый формат</summary>
            <param name="Format">Формат преобразования</param>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.Complex.GetHashCode">
            <summary>Хеш-код числа</summary>
            <returns>Хеш-код числа</returns>
        </member>
        <member name="M:MathService.Complex.Clone">
            <summary>Получение клона</summary>
            <returns>Клон числа</returns>
        </member>
        <member name="M:MathService.Complex.System#ICloneable#Clone">
            <summary>Получение клона</summary>
            <returns>Клон числа</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Object)">
            <summary>Сравнение с другим объектом</summary>
            <param name="obj">Сравниваемый объект</param>
            <returns>Истина, если объект - комплексное число и чдействительная и мнимая части равны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(MathService.Complex)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{MathService#Complex}#Equals(MathService.Complex)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Double)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Double}#Equals(System.Double)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Int16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Int16}#Equals(System.Int16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.UInt16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#UInt16}#Equals(System.UInt16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Byte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Byte}#Equals(System.Byte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.SByte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#SByte}#Equals(System.SByte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Single)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Single}#Equals(System.Single)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Int32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Int32}#Equals(System.Int32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.UInt32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#UInt32}#Equals(System.UInt32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Int64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Int64}#Equals(System.Int64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.UInt64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#UInt64}#Equals(System.UInt64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Rotate(System.Double)">
            <summary>Поворот вектора комплексного числа на угол</summary>
            <param name="w">Угол поворота вектора в комплексной плоскости</param>
            <returns>Комплексное число, повёрнутое на угол</returns>
        </member>
        <member name="M:MathService.Complex.Round(System.Int32)">
            <summary>Округление числа</summary>
            <param name="DigitsCount">Число разрядов</param>
            <returns>Округлённое число</returns>
        </member>
        <member name="M:MathService.Complex.Sqrt">
            <summary>Вычисление квадратного корня числа</summary>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="T:MathService.Consts">
            <summary>Константы</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.yotta">
            <summary>10^24</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.zetta">
            <summary>10^21</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.exa">
            <summary>10^18</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.peta">
            <summary>10^15</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.tera">
            <summary>10^12</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.giga">
            <summary>10^9</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.mega">
            <summary>10^6</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.kilo">
            <summary>10^3</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.hecto">
            <summary>10^2</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.deca">
            <summary>10^1</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.none">
            <summary>10^0</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.deci">
            <summary>10^-1</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.santi">
            <summary>10^-2</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.milli">
            <summary>10^-3</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.micro">
            <summary>10^-6</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.nano">
            <summary>10^-9</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.pico">
            <summary>10^-12</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.femto">
            <summary>10^-15</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.atto">
            <summary>10^-18</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.zepto">
            <summary>10^-21</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.yocto">
            <summary>10^-24</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.yotta">
            <summary>10^24</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.zetta">
            <summary>10^21</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.exa">
            <summary>10^18</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.peta">
            <summary>10^15</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.tera">
            <summary>10^12</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.giga">
            <summary>10^9</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.mega">
            <summary>10^6</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.kilo">
            <summary>10^3</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.hecto">
            <summary>10^2</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.deca">
            <summary>10^1</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.none">
            <summary>10^0</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.deci">
            <summary>10^-1</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.santi">
            <summary>10^-2</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.milli">
            <summary>10^-3</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.micro">
            <summary>10^-6</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.nano">
            <summary>10^-9</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.pico">
            <summary>10^-12</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.femto">
            <summary>10^-15</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.atto">
            <summary>10^-18</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.zepto">
            <summary>10^-21</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.yocto">
            <summary>10^-24</summary>
        </member>
        <member name="F:MathService.Consts.Percent">
            <summary>% = 0.01</summary>
        </member>
        <member name="F:MathService.Consts.e">
            <summary>e = 2.7182818284590452353602874713527</summary>
        </member>
        <member name="F:MathService.Consts.pi05">
            <summary>π/2</summary>
        </member>
        <member name="F:MathService.Consts.pi">
            <summary>π = 3.1415926535897932384626433832795</summary>
        </member>
        <member name="F:MathService.Consts.pi2">
            <summary>2·π</summary>
        </member>
        <member name="F:MathService.Consts.pi3_2">
            <summary>3·π/</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_e">
            <summary>√e</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_pi">
            <summary>√π</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_pi2">
            <summary>√2·π</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_2">
            <summary>√2 = 1.4142135623730950488016887242097</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_2_inv">
            <summary>1 / √2 = 0.707...</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_3">
            <summary>√3 = 1.732050807...</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_5">
            <summary>√5 = 2.236067...</summary>
        </member>
        <member name="F:MathService.Consts.GoldenRatio">
            <summary>Золотое сечение = (√5 + 1)/2</summary>
        </member>
        <member name="F:MathService.Consts.GoldenRatio_Inv">
            <summary>Величина, обратная золотому сечению = (√5 - 1)/2</summary>
        </member>
        <member name="T:MathService.Consts.Geometry">
            <summary>Геометрические константы</summary>
        </member>
        <member name="F:MathService.Consts.Geometry.ToDeg">
            <summary>Константа преобразования радиан в градусы = 180/π</summary>
        </member>
        <member name="F:MathService.Consts.Geometry.ToRad">
            <summary>Константа преобразования градусов в радианы = π/180</summary>
        </member>
        <member name="F:MathService.Consts.Geometry.Pi">
            <summary>Константа π = 3.1415926535897932384626433832</summary>
        </member>
        <member name="F:MathService.Consts.SpeedOfLigth">
            <summary>Скорость света 300`000`000 м/с = 3e8 м/с</summary>
        </member>
        <member name="F:MathService.Consts.SpeedOfLightInVacuum">
            <summary>Скорость света в вакууме 299`792`458 м/с</summary>
        </member>
        <member name="F:MathService.Consts.GravitationConstant">
            <summary>Гравитационная постоянная 6.67384(80)×10^−11 m^3·кг^−1·с^−2</summary>
        </member>
        <member name="F:MathService.Consts.PlanckConstant">
            <summary>Постоянная Планка 6.626 069 57(29) ×10^−34 Жд·с</summary>
        </member>
        <member name="F:MathService.Consts.PlanckConstant_Reduced">
            <summary>Приведённая постоянная Планка 1.054 571 628(53) ×10^−34 Жд·с</summary>
        </member>
        <member name="F:MathService.Consts.ElectroDynamic.Epsilon0">
            <summary>Электрическая постоянная 1/(Mu0 · c^2) = 8,854187817620… ×10^−12 Ф·м^−1</summary>
        </member>
        <member name="F:MathService.Consts.ElectroDynamic.Mu0">
            <summary>Магнитная постоянная 4·π ×10^-7 = 1.25663706E-6 Гн/м</summary>
        </member>
        <member name="F:MathService.Consts.BigPrime_int">
            <summary>0x3ffeffff = 1073676287</summary>
        </member>
        <member name="F:MathService.Consts.BigPrime_long">
            <summary>0x3fffffefffffff = 18014398241046527</summary>
        </member>
        <member name="F:MathService.Consts.ElementaryCharge">
            <summary>Элементарный заряд e = 1,602 176 565(35)·10^−19 Кл</summary>
        </member>
        <member name="F:MathService.Consts.BoltzmanConstant">
            <summary>Постоянная Больцмана k = 1,380 6488(13)·10^−23 Дж/К</summary>
        </member>
        <member name="F:MathService.Consts.AvogadroConstant">
            <summary>Число Авогадро Na = 6,022 141 29(27)·10^23 1/моль</summary>
        </member>
        <member name="F:MathService.Consts.FaradayConstant">
            <summary>Постоянная Фарадея F = e * Na = 96485,33(83) Кл/моль</summary>
        </member>
        <member name="M:MathService.IFactory`1.Create">
            <summary>Создать новый объект</summary>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="T:MathService.Factory`1">
            <summary>Генератор объектов типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип генерируемых объектов</typeparam>
        </member>
        <member name="E:MathService.Factory`1.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
            <summary>Событие возникает при генерации новой строки</summary>
        </member>
        <member name="F:MathService.Factory`1.f_FactoryMethod">
            <summary>Метод генерации объектов</summary>
        </member>
        <member name="P:MathService.Factory`1.Last">
            <summary>Последний сгенерированный объект</summary>
        </member>
        <member name="P:MathService.Factory`1.FactoryMethod">
            <summary>Метод генерации объектов типа <typeparamref name="T"/></summary>
        </member>
        <member name="M:MathService.Factory`1.#ctor(System.Func{`0})">
            <summary>Новый генератор объектов типа <typeparamref name="T"/></summary>
            <param name="CreateMethod">Метод генерации объектов типа <typeparamref name="T"/></param>
        </member>
        <member name="M:MathService.Factory`1.Create">
            <summary>Создать новый объект</summary>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="F:MathService.Forms.ProgressForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:MathService.Forms.ProgressForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MathService.Forms.ProgressForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MathService.ICountable">
            <summary>Объект позволяет определять количество вложенных объектов</summary>
        </member>
        <member name="P:MathService.ICountable.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="P:MathService.ContractClassICountable.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="M:MathService.LambdaEnumerable`1.GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.LambdaEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.LambdaComparer`1">
            <summary>ОБъект, представляющий метод сравнения двух объектов типа <typeparamref name="T"/>, задаваемый lambda-выражением</summary>
            <typeparam name="T">Тип сравниваемых объектов</typeparam>
        </member>
        <member name="M:MathService.LambdaComparer`1.Compare(`0,`0)">
            <summary>
            Сравнивает два объекта и возвращает значение, показывающее, что один объект меньше или больше другого или равен ему.
            </summary>
            <returns>
            Значение Условие Меньше нуля<paramref name="x"/> меньше, чем <paramref name="y"/>.Нуль<paramref name="x"/> равно <paramref name="y"/>.Больше нуля<paramref name="x"/> больше, чем <paramref name="y"/>.
            </returns>
            <param name="x">Первый сравниваемый объект.</param><param name="y">Второй сравниваемый объект.</param>
        </member>
        <member name="M:MathService.LambdaEqualityComparer`1.Equals(`0,`0)">
            <summary>Определяет, равны ли два указанных объекта.</summary>
            <returns>Значение true, если указанные объекты равны; в противном случае — значение false.</returns>
            <param name="x">Первый сравниваемый объект типа <typeparam name="T"/>.</param>
            <param name="y">Второй сравниваемый объект типа <typeparam name="T"/>.</param>
        </member>
        <member name="M:MathService.LambdaEqualityComparer`1.GetHashCode(`0)">
            <summary>Возвращает хэш-код указанного объекта.</summary>
            <returns>Хэш-код указанного объекта.</returns>
            <param name="obj">Объект <see cref="T:System.Object"/>, для которого должен быть возвращен хэш-код.</param>
            <exception cref="T:System.ArgumentNullException">Тип <paramref name="obj"/> является ссылочным типом, значением <paramref name="obj"/> является null.</exception>
        </member>
        <member name="T:MathService.LambdaProperty`1">
            <summary>Класс объектов-свойств, определяемых методами установки и чтения значения</summary>
        </member>
        <member name="F:MathService.LambdaProperty`1.f_GetMethod">
            <summary>Метод получения значения свойства</summary>
        </member>
        <member name="F:MathService.LambdaProperty`1.f_SetMethod">
            <summary>Метод установки значения свойства</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.GetMethod">
            <summary>Метод получения значения свойства</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.SetMethod">
            <summary>Метод установки значения свойства</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.CanRead">
            <summary>Признак возможности чтения значения свойства (если задан метод чтения)</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.CanWrite">
            <summary>Признак возможности устанавливать значение свойства (если задан метод записи)</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="M:MathService.LambdaProperty`1.#ctor(System.Func{`0},System.Action{`0})">
            <summary>Новое лямда свойство</summary>
            <param name="GetMethod">Метод чтения значения</param>
            <param name="SetMethod">Метод записи значения</param>
        </member>
        <member name="M:MathService.LambdaProperty`1.Equals(MathService.LambdaProperty{`0})">
            <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
            <returns>true, если текущий объект равен параметру <paramref name="other"/>, в противном случае — false.</returns>
            <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        </member>
        <member name="M:MathService.LambdaProperty`1.GetHashCode">
            <summary>Играет роль хэш-функции для определенного типа. </summary>
            <returns>Хэш-код для текущего объекта <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.LambdaToString">
            <summary>Форматтер строки с помощью лямда-выражения</summary>
        </member>
        <member name="M:MathService.LambdaToString.#ctor(System.Func{System.String})">
            <summary>Новый ламбда-форматтер</summary>
            <param name="CreateMethod">Метод генерации строки</param>
        </member>
        <member name="T:MathService.ObjectWacher`1">
            <summary>Наблюдатель за объектом</summary>
            <typeparam name="T">Тип наблюдаемого объекта</typeparam>
        </member>
        <member name="F:MathService.ObjectWacher`1.f_Object">
            <summary>Наблюдаемый объект</summary>
        </member>
        <member name="F:MathService.ObjectWacher`1.f_WachMethod">
            <summary>Метод наблюдения</summary>
        </member>
        <member name="P:MathService.ObjectWacher`1.WachMethod">
            <summary>Метод наблюдения</summary>
        </member>
        <member name="P:MathService.ObjectWacher`1.Object">
            <summary>Наблюдаемый объект</summary>
        </member>
        <member name="M:MathService.ObjectWacher`1.#ctor(`0,System.Action{`0},System.Int32)">
            <summary>Инициализация наблюдателя</summary>
            <param name="obj">Наблюдаемый объект</param>
            <param name="WachMethod">Метод наблюдения</param>
            <param name="Timeout">Таймаут потока наблюдения</param>
        </member>
        <member name="M:MathService.ObjectWacher`1.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="P:MathService.ProcessExplorer.FilterToExcludeProcesses">
            <summary>Метод фильтрации процессов, показывающий какие процессы не должны попадать в выборку</summary>
        </member>
        <member name="T:MathService.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:MathService.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:MathService.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface
             and this method is used to notify that some property value changed
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:MathService.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:MathService.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:MathService.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:MathService.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly
            when marked with <see cref="T:MathService.Annotations.MeansImplicitUseAttribute"/>
            or <see cref="T:MathService.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:MathService.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used
            </summary>
        </member>
        <member name="T:MathService.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:MathService.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder
            within a web project. Path can be relative or absolute,
            starting from web root (~)
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC controller. If applied to a method,
            the MVC controller name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, Object)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC partial view. If applied to a method,
            the MVC partial view name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcSupressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling all inspections
            for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>
            </summary>
        </member>
        <member name="T:MathService.Quaternion">
            <summary>Кватернион</summary>
        </member>
        <member name="M:MathService.Quaternion.#ctor(System.Double)">
            <summary>
            Кватерион a + b*i + c*j + d*k
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:MathService.Quaternion.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Кватерион a + b*i + c*j + d*k
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="d"></param>
        </member>
        <member name="M:MathService.Quaternion.op_Multiply(MathService.Quaternion,MathService.Quaternion)">
            <summary>
            </summary>
            <remarks>
            (a1 + b1*i + c1*j + d1*k) * (a2 + b2*i + c2*j + d2*k) =
            
            a1*a2 + a1*b2*i + a1*c2*j + a1*d2*k +
            b1*i*a2 + b1*i*b2*i + b1*i*c2*j + b1*i*d2*k +  
            c1*j*a2 + c1*j*b2*i + c1*j*c2*j + c1*j*d2*k +    
            d1*k*a2 + d1*k*b2*i + d1*k*c2*j + d1*k*d2*k =
            
            a1*a2   + a1*b2*i + a1*c2*j + a1*d2*k +
            b1*a2*i - b1*b2   + b1*c2*k - b1*d2*j +   
            c1*a2*j - c1*b2*k - c1*c2   + c1*d2*i + 
            d1*a2*k + d1*b2*j - d1*c2*i - d1*d2   =
            
             a1*a2 - b1*b2 - c1*c2 - d1*d2 +       
            (a1*b2 + b1*a2 + c1*d2 - d1*c2)*i +    
            (a1*c2 + c1*a2 - b1*d2 + d1*b2)*j +
            (a1*d2 + d1*a2 + b1*c2 - c1*b2)*k =
                                    
             ┌a1 -b1 -c1 -d1┐   ┌a2┐
             │b1  a1 -d1  c1│ x │b2│ = Q1 x q2
             │c1  d1  a1 -b1│   │c2│
             └d1 -c1  b1  a1┘   └d2┘
            
             a1*a2 - b1*b2 - c1*c2 - d1*d2 +       
            (b1*a2 + a1*b2 - d1*c2 + c1*d2)*i +    
            (c1*a2 + d1*b2 + a1*c2 - b1*d2)*j +
            (d1*a2 - c1*b2 + b1*c2 + a1*d2)*k =
            
             ┌a2 -b2 -c2 -d2┐   ┌a1┐
             │b2  a2  d2 -c2│ x │b1│
             │c2 -d2  a2  b2│   │c1│
             └d2  c2 -b2  a2┘   └d1┘
                   
             a1*a2 - b1*b2 - c1*c2 - d1*d2 +       
            (a1*b2 + b1*a2 + c1*d2 - d1*c2)*i +    
            (a1*c2 - b1*d2 + c1*a2 + d1*b2)*j +
            (a1*d2 + b1*c2 - c1*b2 + d1*a2)*k
            
            x| 1  i  j  k
            -+-----------
            1| 1  i  j  k
            i| i -1  k -j
            j| j -k -1  i
            k| k  j -i -1
            
            </remarks>
            <param name="X"></param>
            <param name="Y"></param>
            <returns></returns>
        </member>
        <member name="T:MathService.RegExpConsts">
            <summary>
            
            </summary>
            <remarks>http://html5pattern.com/</remarks>
        </member>
        <member name="F:MathService.RegExpConsts.UserName">
            <summary>2-20 символов, которыми могут быть буквы и цифры, первый символ обязательно буква</summary>
        </member>
        <member name="F:MathService.RegExpConsts.PassworsSimple">
            <summary>Строчные и прописные латинские буквы, цифры</summary>
        </member>
        <member name="F:MathService.RegExpConsts.PassworsAdvanced">
            <summary>Строчные и прописные латинские буквы, цифры, спецсимволы. Минимум 8 символов</summary>
        </member>
        <member name="F:MathService.RegExpConsts.DateStringYYYYMMDD">
            <summary>Дата в формате YYYY-MM-DD</summary>
        </member>
        <member name="F:MathService.RegExpConsts.DateStringYYYYMMDDAdvanced">
            <summary>Более строгая проверка даты в формате YYYY-MM-DD</summary>
        </member>
        <member name="T:MathService.SealedEvent">
            <summary>Изолированное событие</summary>
        </member>
        <member name="E:MathService.SealedEvent.Event">
            <summary>Событие</summary>
        </member>
        <member name="M:MathService.SealedEvent.Invoke(System.Object,System.EventArgs)">
            <summary>Вызвать событие</summary>
            <param name="Sender">Источник события</param><param name="args">Аргументы события</param>
        </member>
        <member name="M:MathService.SealedEvent.BeginInvoke(System.Object,System.EventArgs,System.AsyncCallback,System.Object)">
            <summary>Вызвать событие асинхронно</summary>
            <param name="Sender">Источник события</param><param name="args">Аргументы события</param>
            <param name="CallBack">Метод обработки завершения вызова</param><param name="State">Объект-состояние</param>
        </member>
        <member name="M:MathService.SealedEvent.InvokeFast(System.Object,System.EventArgs)">
            <summary>Быстрый вызов события</summary>
            <param name="Sender">Источник события</param><param name="args">Аргумент события</param>
        </member>
        <member name="T:MathService.SealedEvent`1">
            <summary>Изолированное событие</summary>
            <typeparam name="TEventArgs">Тип параметра аргумента</typeparam>
        </member>
        <member name="E:MathService.SealedEvent`1.Event">
            <summary>Событие</summary>
        </member>
        <member name="M:MathService.SealedEvent`1.Invoke(System.Object,`0)">
            <summary>Вызвать событие</summary>
            <param name="Sender">Источник события</param><param name="args">Аргументы события</param>
        </member>
        <member name="M:MathService.SealedEvent`1.BeginInvoke(System.Object,`0,System.AsyncCallback,System.Object)">
            <summary>Вызвать событие асинхронно</summary>
            <param name="Sender">Источник события</param><param name="args">Аргументы события</param>
            <param name="CallBack">Метод обработки завершения вызова</param><param name="State">Объект-состояние</param>
        </member>
        <member name="M:MathService.SealedEvent`1.InvokeFast(System.Object,`0)">
            <summary>Быстрый вызов события</summary>
            <param name="Sender">Источник события</param><param name="args">Аргумент события</param>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.PolyformRandomGenertor.c_Normal_A">
            <summary>area under rectangle</summary>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.PolyformRandomGenertor.A">
            <summary>area under rectangle</summary>
        </member>
        <member name="M:MathService.Statistic.RandomNumbers.PolyformRandomGenertor.Cauchy(System.Double,System.Double)">
            <summary>Случайная величина с распределением Коши</summary>
            <param name="x0"></param>
            <param name="gamma"></param>
            <returns></returns>
        </member>
        <member name="T:MathService.Statistic.RandomNumbers.RandomGenerator">
            <summary>Генератор случайных чисел</summary>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.RandomGenerator.SystemRandomGenerator">
            <summary>Датчик случайных чисел с равномерным распределением</summary>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.RandomGenerator.f_sigma">
            <summary>Дисперсия</summary>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.RandomGenerator.f_mu">
            <summary>Математическое ожидание</summary>
        </member>
        <member name="P:MathService.Statistic.RandomNumbers.RandomGenerator.sigma">
            <summary>Дисперсия</summary>
        </member>
        <member name="P:MathService.Statistic.RandomNumbers.RandomGenerator.mu">
            <summary>Математическое ожидание</summary>
        </member>
        <member name="P:MathService.Statistic.RandomNumbers.RandomGenerator.Value">
            <summary>Случайное значение</summary>
        </member>
        <member name="M:MathService.Statistic.RandomNumbers.RandomGenerator.GetValue">
            <summary>Новое случайное число</summary><returns>Случайное число</returns>
        </member>
        <member name="T:MathService.Statistic.RandomNumbers.UniformRandomGenerator">
            <summary>Генератор случайных чисел с равномерным распределением</summary>
        </member>
        <member name="T:MathService.Statistic.Histogram">
            <summary>Гистограмма</summary>
        </member>
        <member name="T:MathService.Temp.Simplex">
            <summary>
            Данный класс содержит реализацию симплекс-метода.
            </summary>
            <remarks>
            Изначально был написан на C++, источник: http://marioslapseofreason.blogspot.com/2010/12/linear-programming-simplex-algorithm.html
            Портирование под .NET и добавление проверки начальных условий: Владимир Панченко
            </remarks>
        </member>
        <member name="M:MathService.Temp.Simplex.CheckSimplex(System.Double[],System.Double[0:,0:],System.Double[])">
            <summary>
            Проверяет корректность исходных данных.
            </summary>
            <param name="b">Вектор со значениями правой части неравенств.</param>
            <param name="MaxFunction"></param>
        </member>
        <member name="M:MathService.Temp.Simplex.SetSimplex(System.Double[],System.Double[0:,0:],System.Double[])">
            <param name="maxFunction">Vector with the values of the coefficients for each variable.
            Example: { 2 , 1.5 , 1 } for 2X + (3/2)Y + Z</param>
            <param name="A">Matrix with the coefficient of the left sides of all the inequalities.</param>
            <param name="b">Vector with the values of the right side of the inequalities.</param>
            <returns>Linear program in canonical form</returns>
        </member>
        <member name="M:MathService.Temp.Simplex.DoSimplex(System.Double[],System.Double[0:,0:],System.Double[],System.Double@)">
            <summary>
            Максимизирует целевую функцию с учётом ограничений с помощью симплекс-метода.
            </summary>
            <param name="maxFunction">Вектор коэффицентов целевой функции.</param>
            <param name="A">Матрица коэффициентов при параметрах в левой части неравенств.</param>
            <param name="b">Вектор со значениями правой части неравенств.</param>
            <param name="max">Максимальное значение функции с учётом ограничений.</param>
            <returns>Вектор значений параметров.</returns>
        </member>
        <member name="T:MathService.Temp.Y_Combinator">
            <summary>Y-комбинатор</summary>
        </member>
        <member name="M:MathService.Temp.Y_Combinator.Y``2(System.Func{System.Func{``0,``1},System.Func{``0,``1}})">
            <summary>Y = (λh.λF.F(λx.((h(h))(F))(x))) (λh.λF.F(λx.((h(h))(F))(x)))</summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:MathService.Test.Productivity">
            <summary>
            Тестирование производительности
            </summary>
        </member>
        <member name="M:MathService.Test.Productivity.GetExecutionTime(System.Action,System.Int32,System.Threading.ThreadPriority)">
            <summary>Определение времени выполнения кода </summary>
            <param name="action">Выполняемый код</param>
            <param name="Count">Объём статистики</param>
            <returns>Средняя длительность выполнения кода</returns>
        </member>
        <member name="T:MathService.TimeInterval">
            <summary>Интервальный предикат</summary>
        </member>
        <member name="F:MathService.TimeInterval.f_MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathService.TimeInterval.f_MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathService.TimeInterval.f_Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathService.TimeInterval.f_Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.TimeInterval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathService.TimeInterval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathService.TimeInterval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathService.TimeInterval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.TimeInterval.Length">
            <summary>Протяжённость интервала</summary>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan,System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верзняя граница интервала</param>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan,System.TimeSpan,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan,System.Boolean,System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan,System.Boolean,System.TimeSpan,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathService.TimeInterval.Check(System.TimeSpan)">
            <summary>Проверка на входжение в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <returns>Истина, если величина входит в интервал</returns>
        </member>
        <member name="M:MathService.TimeInterval.IsInclude(MathService.TimeInterval)">
            <summary>
            Проверка вхождения интервала в интервал
            </summary>
            <param name="I">Проверяемый интервал</param>
            <returns>Истина, если проверяемый интервал входит</returns>
        </member>
        <member name="M:MathService.TimeInterval.op_Implicit(MathService.TimeInterval)~System.Predicate{System.TimeSpan}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathService.TimeInterval.op_ExclusiveOr(System.TimeSpan,MathService.TimeInterval)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="x">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathService.TimeInterval.op_ExclusiveOr(MathService.TimeInterval,System.TimeSpan)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathService.DateTimeInterval">
            <summary>Интервальный предикат</summary>
        </member>
        <member name="F:MathService.DateTimeInterval.f_MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathService.DateTimeInterval.f_MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathService.DateTimeInterval.f_Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathService.DateTimeInterval.f_Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.Length">
            <summary>Протяжённость интервала</summary>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime)">
            <summary>Интервал</summary>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime,System.DateTime)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верзняя граница интервала</param>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime,System.DateTime,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime,System.Boolean,System.DateTime)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime,System.Boolean,System.DateTime,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathService.DateTimeInterval.Check(System.DateTime)">
            <summary>Проверка на входжение в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <returns></returns>
        </member>
        <member name="M:MathService.DateTimeInterval.op_Implicit(MathService.DateTimeInterval)~System.Predicate{System.DateTime}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathService.DateTimeInterval.op_ExclusiveOr(System.DateTime,MathService.DateTimeInterval)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="x">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathService.DateTimeInterval.op_ExclusiveOr(MathService.DateTimeInterval,System.DateTime)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathService.DisposableGroup`1">
            <summary>Группа объектов, поддерживающих интерфейс <see cref="T:System.IDisposable">освобождения ресурсов</see></summary>
            <typeparam name="T">Тип объектов, подерживающих интерфейс <see cref="T:System.IDisposable"/></typeparam>
        </member>
        <member name="F:MathService.DisposableGroup`1.f_Items">
            <summary>Массив содержащихся объектов интерфейса <see cref="T:System.IDisposable"/></summary>
        </member>
        <member name="P:MathService.DisposableGroup`1.Count">
            <summary>Число элементов группы</summary>
        </member>
        <member name="P:MathService.DisposableGroup`1.Items">
            <summary>Массив элементов группы</summary>
        </member>
        <member name="P:MathService.DisposableGroup`1.Item(System.Int32)">
            <summary>Элемент группы</summary>
            <param name="i">Номер элемента группы</param>
            <returns>Элемент группы с номером <paramref name="i"/></returns>
        </member>
        <member name="M:MathService.DisposableGroup`1.#ctor(`0[])">
            <summary>Группа <typeparam name="T">объектов</typeparam> интерфейса <see cref="T:System.IDisposable"/></summary>
            <param name="item"><typeparam name="T">Объект</typeparam> интерфейса <see cref="T:System.IDisposable"/></param>
        </member>
        <member name="M:MathService.DisposableGroup`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Группа <typeparam name="T">объектов</typeparam> интерфейса <see cref="T:System.IDisposable"/></summary>
            <param name="items">Перечисление <typeparam name="T">объектов</typeparam> интерфейса <see cref="T:System.IDisposable"/></param>
        </member>
        <member name="M:MathService.DisposableGroup`1.Dispose">
            <summary>Освободить ресурсы группы</summary>
        </member>
        <member name="M:MathService.DisposableGroup`1.GetEnumerator">
            <summary>Получить перечислитель элементов группы</summary>
            <returns>Перечислитель элементов группы</returns>
        </member>
        <member name="M:MathService.DisposableGroup`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.ICloneable`1">
            <summary>Объект поддерживает клонирование</summary>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="T:MathService.IIndexableRead`2">
            <summary>Объект индексируемый только для чтения значений</summary>
            <typeparam name="TIndex">Тип индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathService.IIndexableRead`2.Item(`0)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index">Индекс</param>
        </member>
        <member name="T:MathService.IIndexableRead`3">
            <summary>Объект индексируемый только для чтения значений с двумя индексами</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="P:MathService.IIndexableRead`3.Item(`0,`1)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index1">Первый индекс</param>
            <param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathService.IIndexableWrite`2">
            <summary>Объект индексируемый только для записи значений</summary>
            <typeparam name="TIndex">Тип индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathService.IIndexableWrite`2.Item(`0)">
            <summary>Индексатор объекта только для записи</summary><param name="index">Индекс</param>
        </member>
        <member name="T:MathService.IIndexableWrite`3">
            <summary>Объект индексируемый только для записи значений с двумя индексами</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="P:MathService.IIndexableWrite`3.Item(`0,`1)">
            <summary>Индексатор объекта только для записи</summary>
            <param name="index1">Первый индекс</param><param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathService.IIndexable`2">
            <summary>Объект индексируемый</summary>
            <typeparam name="TIndex">Тип индекса</typeparam><typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathService.IIndexable`2.Item(`0)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="T:MathService.IIndexable`3">
            <summary>Объект индексируемый с двумя параметрами индекса</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathService.IIndexable`3.Item(`0,`1)">
            <summary>Индексатор объекта</summary>
            <param name="index1">Первый индекс</param><param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathService.IIndexable`1">
            <summary>Объект индексируемый с целочисленным индексом</summary>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="T:MathService.INamedRead">
            <summary>Объект, обладающий именем</summary>
        </member>
        <member name="P:MathService.INamedRead.Name">
            <summary>Имя объекта</summary>
        </member>
        <member name="T:MathService.INamed">
            <summary>Объект с возможностью задавать имя</summary>
        </member>
        <member name="P:MathService.INamed.Name">
            <summary>Имя объекта</summary>
        </member>
        <member name="T:MathService.Matrix">
            <summary>Матрица NxM</summary>
            <remarks>
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.Matrix.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.Matrix.GetTransvection(MathService.Matrix,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.Matrix.f_N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.Matrix.f_M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathService.Matrix.f_Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.Matrix.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.Matrix.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.Matrix.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.Matrix.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.Matrix.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.Matrix.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.Matrix.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.Matrix.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Double})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Double})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.Matrix.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.Matrix.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.Matrix.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.Matrix.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.Matrix.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.Matrix.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.Matrix.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.Matrix.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.Matrix.LUDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower traingular matrix is returned</param>
            <param name="U">An array where the upper traingular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathService.Matrix.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.Matrix.op_Addition(MathService.Matrix,MathService.Matrix)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.Matrix.op_Subtraction(MathService.Matrix,MathService.Matrix)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.Matrix.op_Multiply(MathService.Matrix,MathService.Matrix)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.Matrix.op_Division(MathService.Matrix,MathService.Matrix)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.Matrix.op_BitwiseOr(MathService.Matrix,MathService.Matrix)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.Matrix.op_Implicit(System.Double)~MathService.Matrix">
            <summary>Оператор неявного преведения типа вещественного числа двойной точнойсти к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порадка 1х1</returns>
        </member>
        <member name="F:MathService.SpecialFunctions.pi_2">
            <summary>Pi/2</summary>
        </member>
        <member name="F:MathService.SpecialFunctions.Eps">
            <summary>Точность алгоритмов 5e-16</summary>
        </member>
        <member name="T:MathService.SpecialFunctions.Gamma">
            <summary>Гамма-функция</summary>
        </member>
        <member name="T:MathService.SpecialFunctions.BesselFunction">
            <summary>Класс функций Бесселя</summary>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.J0(System.Double)">
            <summary>Функция Бесселя 0 порядка</summary>
            <param name="x">Аргумент</param>
            <returns>Значение функции Бесселя нулевого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.J1(System.Double)">
            <summary>Функция Бесселя 1 порядка</summary>
            <param name="x">Аргумент функции</param>
            <returns>Значение функции Бесселя первого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.Jn(System.Int32,System.Double)">
            <summary>Функция Бесселя n порядка</summary>
            <param name="n">Порядок функции Бесселя</param>
            <param name="x">Аргумент Функции Бесселя</param>
            <returns>Значение функции Бесселя n порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.Y0(System.Double)">
            <summary>Функция Бесселя второго типа, нулевого порядка</summary>
            <param name="x">Аргумент функции Бесселя второго типа, нулевого порядка</param>
            <returns>Значение функции Бесселя второго типа, нулевого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.Y1(System.Double)">
            <summary>Функция Бесселя второго типа, первого порядка</summary>
            <param name="x">Аргумент функции Бесселя второго типа, первого порядка</param>
            <returns>Значение функции Бесселя второго типа, первого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.Yn(System.Int32,System.Double)">
            <summary>Функция Бесселя второго типа, n порядка</summary>
            <param name="n">Порядок функции Бесселя второго типа</param>
            <param name="x">Аргумент функции Бесселя второго типа, n порядка</param>
            <returns>Значение функции Бесселя второго типа, n порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.I0(System.Double)">
            <summary>Модифицированная функция Бесселя нулевого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя нулевого порядка</param>
            <returns>Значение модифицированной функции Бесселя нулевого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.I1(System.Double)">
            <summary>Модифицированная функция Бесселя первого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя первого порядка</param>
            <returns>Значение модифицированной функции Бесселя первого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.K0(System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, нулевого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, нулевого порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, нулевого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.K1(System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, первого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, первого порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, первого порядка</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">x меньше 0</exception>
        </member>
        <member name="M:MathService.SpecialFunctions.BesselFunction.Kn(System.Int32,System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, n порядка </summary>
            <param name="n">Порядок модифицированной функции Бесселя второго типа</param>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, n порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, n порядка</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">при x меньше, либо = 0</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">|n| больше 31</exception>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="T:MathService.SpecialFunctions.Distribution.Normal">
            <summary>Нормальное распределение</summary>
        </member>
        <member name="M:MathService.SpecialFunctions.Distribution.Normal.ErrorFunction(System.Double)">
            <summary>Интеграл от exp{-t^2} от нуля до x / .5 sqrt(pi)</summary>
            <param name="x">Аргумент функции нормального распределения</param>
            <returns>Значение нормального распределения</returns>
        </member>
        <member name="F:MathService.SpecialFunctions.c_FibonachiPhi">
            <summary>(1+sqrt(5))/2</summary>
        </member>
        <member name="F:MathService.SpecialFunctions.c_InvSqrt5">
            <summary>1/sqrt(5)</summary>
        </member>
        <member name="M:MathService.SpecialFunctions.BinomialCoefficient(System.Int32,System.Int32)">
            <summary>Биномиальный коэффициент</summary>
            <param name="n">Показатель степени бинома</param>
            <param name="k">Индекс коэффициента</param>
            <returns>Биномиальный коэффициент (n, k)</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.KroneckerDelta(System.Int32,System.Int32)">
            <summary>Символ Кронекера δ(i,j) = 1 - если i = j, и = 0 - если i ≠ j</summary>
            <param name="i">Индекс</param><param name="j">Индекс</param>
            <returns>1 - если i = j, и = 0 - если i ≠ j</returns>
        </member>
        <member name="T:MathService.ComplexExtentions">
            <summary>Методы-расширения комплексных чисел</summary>
        </member>
        <member name="M:MathService.ComplexExtentions.ToRe(MathService.Complex[])">
            <summary>Преобразование массива комплексных чисел в масив действительных</summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Массив действительных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToIm(MathService.Complex[])">
            <summary>Массив комплексных чисел в массив значений мнимых чисел</summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Массив значений комплексных мнимых чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToAbs(MathService.Complex[])">
            <summary>Массив комплексных чисел в массив модулей</summary>
            <param name="c">Массив сомплексных чисел</param>
            <returns>Массив модулей комплексных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToArg(MathService.Complex[])">
            <summary>Массив сомплексных чисел в массив аргументов</summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Массив аргументов комплексных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToReImArray(MathService.Complex[])">
            <summary>
            Массив комплексных чисел в двумерный массив действительных и мнимых частей, где
            Re = V[i,0]
            Im = V[i,1]
            </summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Двумерный массив вещественных и мнимых частей</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToAbsArgArray(MathService.Complex[])">
            <summary>
            Массив комплексных чисел в двумерный массив модулей и аргументов частей, где
            Abs = V[i,0]
            Arg = V[i,1]
            </summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Двумерный массив Модулей и аргументов</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToComplex(System.Double[])">
            <summary>Преобразовать массив действительных в массив комплексных чисел</summary>
            <param name="Re">Массив действительных чисел</param>
            <returns>Массив комплексных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToComplex(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив действительных в массив комплексных чисел</summary>
            <param name="Values">Двумерный массив действительных чисел, где Re = V[i,0], Im = V[i,1]</param>
            <returns>Массив комплексных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.GetAbs(MathService.Complex[])">
            <summary>Преобразование в массив модулей</summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Массив модулей комплексных чисел</returns>
        </member>
        <member name="F:MathService.Interval`1.f_MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathService.Interval`1.f_MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathService.Interval`1.f_Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathService.Interval`1.f_Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.Interval`1.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathService.Interval`1.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathService.Interval`1.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathService.Interval`1.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="M:MathService.Interval`1.#ctor(`0,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верзняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval`1.#ctor(`0,`0,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы? (default:true)</param>
        </member>
        <member name="M:MathService.Interval`1.#ctor(`0,System.Boolean,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval`1.#ctor(`0,System.Boolean,`0,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval`1.GetHashCode">
            <summary>Играет роль хэш-функции для определенного типа. </summary>
            <returns>Хэш-код для текущего объекта <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Interval`1.Equals(MathService.Interval{`0})">
            <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
            <returns>true, если текущий объект равен параметру <paramref name="other"/>, в противном случае — false.</returns>
            <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        </member>
        <member name="M:MathService.Interval`1.Equals(System.Object)">
            <summary>
            Определяет, равен ли заданный объект <see cref="T:System.Object"/> текущему объекту <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true, если указанный объект <see cref="T:System.Object"/> равен текущему объекту <see cref="T:System.Object"/>; в противном случае — false.
            </returns>
            <param name="obj">Объект <see cref="T:System.Object"/>, который требуется сравнить с текущим объектом <see cref="T:System.Object"/>.</param>
            <exception cref="T:System.NullReferenceException">Параметр <paramref name="obj"/> имеет значение null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Interval`1.System#ICloneable#Clone">
            <summary>Создает новый объект, который является копией текущего экземпляра.</summary>
            <returns>Новый объект, являющийся копией этого экземпляра.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Interval`1.ToString">
            <summary>
            Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.
            </summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Interval`1.op_Implicit(MathService.Interval{`0})~System.Predicate{`0}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathService.Interval`1.op_ExclusiveOr(`0,MathService.Interval{`0})">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="Value">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathService.Interval`1.op_ExclusiveOr(MathService.Interval{`0},`0)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="Value">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathService.Interval">
            <summary>Интервал вещественых значений двойной точности</summary>
        </member>
        <member name="M:MathService.Interval.Comparer_Length(MathService.Interval,MathService.Interval)">
            <summary>Метод сравнения двух интервалов</summary>
            <param name="a">Первый сравниваемый интервал</param>
            <param name="b">Второй сравниваемый интервал</param>
            <returns>1 - если первый интервал больше второго, -1 - если первый интервал меньше второго, 0 - если интервалы равны</returns>
        </member>
        <member name="P:MathService.Interval.Length">
            <summary>Длина интервала</summary>
        </member>
        <member name="P:MathService.Interval.Middle">
            <summary>Середина интервала</summary>
        </member>
        <member name="M:MathService.Interval.#ctor(System.Double,System.Double)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верзняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval.#ctor(System.Double,System.Double,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathService.Interval.#ctor(System.Double,System.Boolean,System.Double)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval.#ctor(System.Double,System.Boolean,System.Double,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval.ToString(System.String,System.IFormatProvider)">
            <summary>Форматирует значение текущего экземпляра с использованием заданного формата.</summary>
            <returns>Объект <see cref="T:System.String"/> содержит значение текущего экземпляра в заданном формате.</returns>
            <param name="format">
            Объект <see cref="T:System.String"/>, задающий используемый формат.— или — 
            Значение null для использования формата по умолчанию, определенного для типа реализации 
            <see cref="T:System.IFormattable"/>. 
            </param>
            <param name="formatProvider">
            Объект <see cref="T:System.IFormatProvider"/>, используемый для форматирования значения.— или — 
            Значение null для получения сведений о форматировании чисел на основе текущего значения параметра языкового 
            стандарта операционной системы. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.MatrixComplex">
            <summary>Матрица NxM</summary>
            <remarks>
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.MatrixComplex.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetTransvection(MathService.MatrixComplex,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixComplex.f_N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixComplex.f_M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:MathService.MatrixComplex.f_Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixComplex.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixComplex.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixComplex.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixComplex.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixComplex.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixComplex.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixComplex.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixComplex.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Int32,System.Func{System.Int32,System.Int32,MathService.Complex})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,MathService.Complex})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixComplex.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetImverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixComplex.LUDecomposition(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower traingular matrix is returned</param>
            <param name="U">An array where the upper traingular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathService.MatrixComplex.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_Addition(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_Subtraction(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_Multiply(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_Division(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_BitwiseOr(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_Implicit(MathService.Complex)~MathService.MatrixComplex">
            <summary>
            Оператор неявного преведения типа вещественного числа двойной точнойсти к типу 
            Матрица порядка 1х1
            </summary>
            <param name="X">Приводимое число</param>
            <returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:MathService.MatrixDecimal">
            <summary>Матрица NxM</summary>
            <remarks>
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.MatrixDecimal.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetTransvection(MathService.MatrixDecimal,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixDecimal.f_N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixDecimal.f_M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:MathService.MatrixDecimal.f_Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixDecimal.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixDecimal.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.MatrixDecimal.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.MatrixDecimal.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:MathService.MatrixDecimal.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Decimal})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixDecimal.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Decimal})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixDecimal.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetImverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixDecimal.LUDecomposition(System.Decimal[0:,0:],System.Decimal[0:,0:]@,System.Decimal[0:,0:]@,System.Decimal[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower traingular matrix is returned</param>
            <param name="U">An array where the upper traingular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathService.MatrixDecimal.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Addition(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Subtraction(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Multiply(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Division(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_BitwiseOr(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Implicit(System.Decimal)~MathService.MatrixDecimal">
            <summary>
            Оператор неявного преведения типа вещественного числа двойной точнойсти к типу 
            Матрица порядка 1х1
            </summary>
            <param name="X">Приводимое число</param>
            <returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:MathService.MatrixFloat">
            <summary>Матрица NxM</summary>
            <remarks>
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.MatrixFloat.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetTransvection(MathService.MatrixFloat,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixFloat.f_N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixFloat.f_M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:MathService.MatrixFloat.f_Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixFloat.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixFloat.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixFloat.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixFloat.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixFloat.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixFloat.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixFloat.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixFloat.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.MatrixFloat.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.MatrixFloat.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:MathService.MatrixFloat.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Single})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixFloat.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Single})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixFloat.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetImverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixFloat.LUDecomposition(System.Single[0:,0:],System.Single[0:,0:]@,System.Single[0:,0:]@,System.Single[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower traingular matrix is returned</param>
            <param name="U">An array where the upper traingular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathService.MatrixFloat.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Addition(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Subtraction(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Multiply(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Division(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_BitwiseOr(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Implicit(System.Single)~MathService.MatrixFloat">
            <summary>
            Оператор неявного преведения типа вещественного числа двойной точнойсти к типу 
            Матрица порядка 1х1
            </summary>
            <param name="X">Приводимое число</param>
            <returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:MathService.MatrixInt">
            <summary>Матрица NxM</summary>
            <remarks>
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.MatrixInt.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetTransvection(MathService.MatrixInt,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixInt.f_N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixInt.f_M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:MathService.MatrixInt.f_Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixInt.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixInt.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixInt.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixInt.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixInt.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixInt.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixInt.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixInt.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.MatrixInt.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.MatrixInt.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:MathService.MatrixInt.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixInt.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixInt.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixInt.GetImverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixInt.LUDecomposition(System.Int32[0:,0:],System.Int32[0:,0:]@,System.Int32[0:,0:]@,System.Int32[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower traingular matrix is returned</param>
            <param name="U">An array where the upper traingular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathService.MatrixInt.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Addition(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Subtraction(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Multiply(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Division(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_BitwiseOr(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Implicit(System.Int32)~MathService.MatrixInt">
            <summary>
            Оператор неявного преведения типа вещественного числа двойной точнойсти к типу 
            Матрица порядка 1х1
            </summary>
            <param name="X">Приводимое число</param>
            <returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:MathService.MatrixLong">
            <summary>Матрица NxM</summary>
            <remarks>
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.MatrixLong.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetTransvection(MathService.MatrixLong,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixLong.f_N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixLong.f_M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:MathService.MatrixLong.f_Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixLong.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixLong.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixLong.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixLong.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixLong.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixLong.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixLong.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixLong.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.MatrixLong.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.MatrixLong.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:MathService.MatrixLong.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Int64})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixLong.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Int64})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixLong.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixLong.GetImverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixLong.LUDecomposition(System.Int64[0:,0:],System.Int64[0:,0:]@,System.Int64[0:,0:]@,System.Int64[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note: This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower traingular matrix is returned</param>
            <param name="U">An array where the upper traingular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathService.MatrixLong.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Addition(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Subtraction(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Multiply(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Division(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_BitwiseOr(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Implicit(System.Int64)~MathService.MatrixLong">
            <summary>
            Оператор неявного преведения типа вещественного числа двойной точнойсти к типу 
            Матрица порядка 1х1
            </summary>
            <param name="X">Приводимое число</param>
            <returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:MathService.TimeoutEvent`1">
            <summary>Класс задержки реакции на событие</summary>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
        </member>
        <member name="M:MathService.TimeoutEvent`1.Subscribe(System.Int32,System.EventHandler{`0},System.EventHandler{`0})">
            <summary>Метод подписки на событие</summary>
            <param name="Timeout">Таймаут</param>
            <param name="OnTimeout">Метод обработки первичного вызова события</param>
            <param name="OnInvoke">Метод обраобтки вторичного события</param>
            <returns>Обработчик исходного события</returns>
        </member>
        <member name="F:MathService.TimeoutEvent`1.c_Infinite">
            <summary>Константа бесконечного периода ожидания</summary>
        </member>
        <member name="T:MathService.TimeoutEvent`1.Info">
            <summary>Аргумент события</summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.Info.EventSender">
            <summary>Источник сходного события</summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.Info.E">
            <summary>Акргумент исходного события</summary>
        </member>
        <member name="M:MathService.TimeoutEvent`1.Info.#ctor(System.Object,`0)">
            <summary>Аргумент события</summary>
            <param name="EventSender">Источник исходного события</param>
            <param name="e">Аргумент исходного события</param>
        </member>
        <member name="E:MathService.TimeoutEvent`1.Invoked">
            <summary>Первычная генерация события</summary>
        </member>
        <member name="M:MathService.TimeoutEvent`1.OnInvoked(MathService.TimeoutEvent{`0}.Info)">
            <summary>Метод первичной генерации события <see cref="E:MathService.TimeoutEvent`1.Invoked"/></summary>
            <param name="e">Аргумент первичного вызова события</param>
        </member>
        <member name="E:MathService.TimeoutEvent`1.Timeouted">
            <summary>Событие, возникающее после последнего вызова метода <see cref="M:MathService.TimeoutEvent`1.Invoke(System.Object,`0)"/> через период времени <see cref="P:MathService.TimeoutEvent`1.Timeout"/></summary>
        </member>
        <member name="M:MathService.TimeoutEvent`1.OnTimeouted(MathService.TimeoutEvent{`0}.Info)">
            <summary>Мeтод генерации события <see cref="E:MathService.TimeoutEvent`1.Timeouted"/></summary>
            <param name="e">Аргумент события</param>
        </member>
        <member name="F:MathService.TimeoutEvent`1.f_Timer">
            <summary>Таймер</summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1.f_Timeout">
            <summary>Период времени таймаута</summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1.f_LastCallTime">
            <summary>Время последнего вызова</summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1.f_InProcess">
            <summary>Признак ожидания таймаута события</summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1.f_LastEventArgs">
            <summary>Аргумент последнего выхова метода <see cref="M:MathService.TimeoutEvent`1.Invoke(System.Object,`0)"/></summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1.f_NeedAbort">
            <summary>Признак ожидания отмены генерации события <see cref="E:MathService.TimeoutEvent`1.Timeouted"/></summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.Timeout">
            <summary>Задейржка во времени генерации события <see cref="E:MathService.TimeoutEvent`1.Timeouted"/> в миллисекундах</summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.LastCallTime">
            <summary>Время последнего выхова метода <see cref="M:MathService.TimeoutEvent`1.Invoke(System.Object,`0)"/></summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.InProcess">
            <summary>Признак ожидания генерации события <see cref="E:MathService.TimeoutEvent`1.Invoked"/></summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.NeedAbort">
            <summary>Признак отмены генерации собития <see cref="E:MathService.TimeoutEvent`1.Timeouted"/></summary>
        </member>
        <member name="M:MathService.TimeoutEvent`1.#ctor(System.Int32)">
            <summary>Инициализация нового объекта задержки генерации соытия</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.#ctor(System.Int32,System.EventHandler{`0})">
            <summary>Инициализация нового объекта задержки генерации соытия</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
            <param name="OnTimeout">Метод вторичной обработки события</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.#ctor(System.Int32,System.EventHandler{`0},System.EventHandler{`0})">
            <summary>Инициализация нового объекта задержки генерации соытия</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
            <param name="OnTimeout">Метод вторичной обработки события</param>
            <param name="OnInvoke">Метод первичной обработки события</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.OnTimer(System.Object)">
            <summary>Метод оброботки события таймера</summary>
            <param name="State">Состояние таймера</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.Invoke(System.Object,`0)">
            <summary>Метод генерации события</summary>
            <param name="EventSender">Источник события</param>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.Abort">
            <summary>Отмена реакции на событие</summary>
        </member>
        <member name="T:MathService.Time.TimeCounter">
            <summary>
            Измеритель времени
            </summary>
        </member>
        <member name="F:MathService.Time.TimeCounter.f_Started">
            <summary>Флаг состояния</summary>
        </member>
        <member name="F:MathService.Time.TimeCounter.f_LockObject">
            <summary>Объект межпотоковой синхронизации</summary>
        </member>
        <member name="P:MathService.Time.TimeCounter.IsStarted">
            <summary>Состояние измерителя</summary>
        </member>
        <member name="P:MathService.Time.TimeCounter.TotalTime">
            <summary>Прошло времени</summary>
        </member>
        <member name="M:MathService.Time.TimeCounter.Start">
            <summary>Запуск</summary>
        </member>
        <member name="M:MathService.Time.TimeCounter.Stop">
            <summary>Остановка</summary>
        </member>
        <member name="M:MathService.Time.TimeCounter.Reset">
            <summary>Сброс измерителя</summary>
        </member>
        <member name="T:MathService.Trees.ITreeItemEx">
            <summary>Методы-расширения интерфейса элемента двусвязного дерева</summary>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.GetRootItem``1(``0)">
            <summary>Определение корня дерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns>КОрневой объект дерева объектов</returns>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.OrderWalk``1(``0,MathService.Trees.ITreeItemEx.OrderWalkType,System.Int32)">
            <summary>Обход элементов поддерева начиная с текущего в порядке: текущий, дочерний, следующий по уровню</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.GetParents``1(``0)">
            <summary>Получить все родительские элементы</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns></returns>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.GetLevelItems``1(``0)">
            <summary>Получить все элементы дочернего уровня поддерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns></returns>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.GetChilds``1(``0)">
            <summary>Получить все дочерние элементы поддерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns></returns>
        </member>
        <member name="T:MathService.Trees.ITreeItem`1">
            <summary>Элемент двусвязного дерева</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MathService.Trees.ITreeItem`1.Parent">
            <summary>Родительский узел</summary>
        </member>
        <member name="P:MathService.Trees.ITreeItem`1.Child">
            <summary>Дочерний узел</summary>
        </member>
        <member name="P:MathService.Trees.ITreeItem`1.Prev">
            <summary>Предыдущий узел уровня</summary>
        </member>
        <member name="P:MathService.Trees.ITreeItem`1.Next">
            <summary>Следующий узел дерева</summary>
        </member>
        <member name="P:MathService.Trees.Tree`1.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="P:MathService.Trees.Tree`1.Item(System.Int32)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="P:MathService.Trees.Tree`1.MathService#IIndexable{System#Int32,MathService#Trees#ITree{T}}#Item(System.Int32)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="P:MathService.Trees.Tree`1.MathService#IIndexableWrite{System#Int32,MathService#Trees#ITree{T}}#Item(System.Int32)">
            <summary>Индексатор объекта только для записи</summary><param name="index">Индекс</param>
        </member>
        <member name="P:MathService.Trees.Tree`1.MathService#IIndexableRead{System#Int32,MathService#Trees#ITree{T}}#Item(System.Int32)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index">Индекс</param>
        </member>
        <member name="M:MathService.Trees.Tree`1.System#Collections#Generic#IEnumerable{MathService#Trees#ITree{T}}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.Trees.Tree`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.UsingDisposableObject`1">
            <summary>Класс-обёртка для inline-доступа к свойствам созданного объекта, наследующего интерфейс IDisposasble</summary>
            <typeparam name="T">Тип используемого объекта, наследующего интерфейс IDIsposable</typeparam>
        </member>
        <member name="M:MathService.UsingDisposableObject`1.#ctor(`0)">
            <summary>Новая обёртка для используемого объекта</summary>
            <param name="Obj">Используемый объект</param>
        </member>
        <member name="M:MathService.UsingDisposableObject`1.GetValue``1(System.Func{`0,``0})">
            <summary>Получить значение от объекта</summary>
            <typeparam name="TValue">Тип значения, получаемого от объекта</typeparam>
            <param name="f">Метод получения значения</param>
            <returns>Значение, полученное от объекта указанным методом</returns>
        </member>
        <member name="T:MathService.UsingObject`1">
            <summary>Оболочка, обеспечивающая освобождение ресурсов указаннцм методом для указанного объекта</summary>
            <typeparam name="T">Тип объекта, с которым работает оболочка</typeparam>
        </member>
        <member name="F:MathService.UsingObject`1.f_Obj">
            <summary>Используемый объект</summary>
        </member>
        <member name="F:MathService.UsingObject`1.f_Disposer">
            <summary>МЕтод освобождения ресурсов</summary>
        </member>
        <member name="P:MathService.UsingObject`1.Object">
            <summary>Используемый объект</summary>
        </member>
        <member name="M:MathService.UsingObject`1.#ctor(`0,System.Action{`0})">
            <summary>Упаковка объекта в оболочку с указанием метода освобождения ресурсов, занимаемых указанным объектом</summary>
            <param name="obj">Уничтожаемый объект</param>
            <param name="Disposer">Метод освобождения ресурсов</param>
        </member>
        <member name="M:MathService.UsingObject`1.Dispose">
            <summary>Разрушение обёртки, влекущее разрушение исопльзуемого объекта</summary>
        </member>
        <member name="M:MathService.UsingObject`1.op_Implicit(MathService.UsingObject{`0})~`0">
            <summary>Оператор неявного приведения типов</summary>
            <param name="obj">ОБъект-оболочка</param>
            <returns>Внутренний объект</returns>
        </member>
        <member name="T:MathService.Values.AbstractSetOf`1">
            <summary>Абстрактное множество элементов</summary>
            <typeparam name="T">Тип элементов множества</typeparam>
        </member>
        <member name="P:MathService.Values.AbstractSetOf`1.Power">
            <summary>Мощность множества</summary>
        </member>
        <member name="M:MathService.Values.AbstractSetOf`1.Contains(`0)">
            <summary>Признак вхождения элемента в множество</summary>
            <param name="value">Проверяемый элемент</param>
            <returns>Истина, если элемент принедлежит множеству</returns>
        </member>
        <member name="M:MathService.Values.AbstractSetOf`1.NotContains(`0)">
            <summary>Признак того, что элемент не входит в множество</summary>
            <param name="value">Проверяемый элемент</param>
            <returns>Истина, если элемент не принадлежит множеству</returns>
        </member>
        <member name="M:MathService.Values.AbstractSetOf`1.GetEnumerator">
            <summary>Получить перечислитель множества</summary>
            <returns>Перечислитель множества</returns>
        </member>
        <member name="M:MathService.Values.AbstractSetOf`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель множества</summary>
            <returns>Перечислитель множества</returns>
        </member>
        <member name="T:MathService.Values.IResetable">
            <summary>Объект, позволяющий осуществлять сброс своего состояния</summary>
        </member>
        <member name="M:MathService.Values.IResetable.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="T:MathService.Values.IValue`1">
            <summary>Объект, позволяющий читать и устанавливать значение</summary>
            <typeparam name="T">Тип значения объекта</typeparam>
        </member>
        <member name="P:MathService.Values.IValue`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathService.Values.IValueRead`1">
            <summary>Объект, обладающий значением</summary>
            <typeparam name="T">Тип значения объекта</typeparam>
        </member>
        <member name="P:MathService.Values.IValueRead`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathService.Values.IValueWrite`1">
            <summary>Объект, позволяющий определять значение</summary>
            <typeparam name="T">Тип значений объекта</typeparam>
        </member>
        <member name="P:MathService.Values.IValueWrite`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathService.Values.LazyValue`1">
            <summary>"Ленивое" значение</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="F:MathService.Values.LazyValue`1.f_Initializator">
            <summary>Инициализатор значения</summary>
        </member>
        <member name="F:MathService.Values.LazyValue`1.f_Value">
            <summary>Значение</summary>
        </member>
        <member name="F:MathService.Values.LazyValue`1.f_LockObject">
            <summary>Объект кросспоточной блокировки</summary>
        </member>
        <member name="F:MathService.Values.LazyValue`1.f_Initialized">
            <summary>Флаг инициализации</summary>
        </member>
        <member name="P:MathService.Values.LazyValue`1.Initialized">
            <summary>Признак инициализации</summary>
        </member>
        <member name="P:MathService.Values.LazyValue`1.Value">
            <summary>Значение</summary>
        </member>
        <member name="M:MathService.Values.LazyValue`1.#ctor(System.Func{`0})">
            <summary>Создание нового "ленивого" значения</summary>
            <param name="Initializator">Инициализатор значения</param>
        </member>
        <member name="M:MathService.Values.LazyValue`1.Initialize(System.Func{`0})">
            <summary>Инициализация "ленивого" значения</summary>
            <param name="Initializator">Инициализатор</param>
        </member>
        <member name="M:MathService.Values.LazyValue`1.System#IInitializable#Initialize">
            <summary>Невный вызов метода инициализации для интерфейса IInitializable</summary>
        </member>
        <member name="M:MathService.Values.LazyValue`1.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="M:MathService.Values.LazyValue`1.op_Implicit(MathService.Values.LazyValue{`0})~`0">
            <summary>Оператор неявного преобразования "ленивого" значения в обычное</summary>
            <param name="value">"Ленивое" значение</param>
            <returns>Обычное значение, получаемое при вычислении "ленивого" значения</returns>
        </member>
        <member name="M:MathService.Values.LazyValue`1.op_Implicit(System.Func{`0})~MathService.Values.LazyValue{`0}">
            <summary>Оператор неявного преобразования метода инициализации в "ленивое значение"</summary>
            <param name="Initializator">Метод инициализации "ленивого" значения</param>
            <returns>"Ленивое" значение с указанным методом инициализации</returns>
        </member>
        <member name="T:MathService.Values.LinearQueue`1">
            <summary>
            Очередь с линейным доступом
            </summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
        </member>
        <!-- Проигнорирован некорректный комментарий XML для члена "T:MathService.Values.ObjectSelector`1" -->
        <member name="F:MathService.Values.ObjectSelector`1.f_Selector">
            <summary>Метод выбора одного из значений ряда источников объектов</summary>
        </member>
        <member name="F:MathService.Values.ObjectSelector`1.f_Values">
            <summary>Массив "ленивых" значений, используемиых в качестве генераторов объектов </summary>
        </member>
        <member name="F:MathService.Values.ObjectSelector`1.f_CanRead">
            <summary>Метод, определяющий возможность чтения данных из источников</summary>
        </member>
        <member name="P:MathService.Values.ObjectSelector`1.Value">
            <summary>Очередное значение из вектора генераторов значений</summary>
        </member>
        <member name="P:MathService.Values.ObjectSelector`1.CanRead">
            <summary>Признак возможности чтения объекта</summary>
        </member>
        <member name="M:MathService.Values.ObjectSelector`1.#ctor(System.Func{`0[],System.Int32},System.Func{System.Boolean},System.Func{`0}[])">
            <summary>Новый генератор последовательности объектов из источника параллельных значений</summary>
            <param name="Selector">Метод выбора значения</param>
            <param name="CanRead">Метод определения возможности чтения значения</param>
            <param name="Generator">Массив генераторов объектов "ленивых" значений</param>
        </member>
        <member name="M:MathService.Values.ObjectSelector`1.#ctor(System.Func{`0[],System.Int32},System.Func{System.Boolean},System.Collections.Generic.IEnumerable{System.Func{`0}})">
            <summary>Новый генератор последовательности объектов из источника параллельных значений</summary>
            <param name="Selector">Метод выбора значения</param>
            <param name="CanRead">Метод определения возможности чтения значения</param>
            <param name="GeneratorsEnum">Массив генераторов объектов "ленивых" значений</param>
        </member>
        <member name="T:MathService.Values.SetOf`1">
            <summary>Множество объектов типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип элементов множества</typeparam>
        </member>
        <member name="P:MathService.Values.SetOf`1.Mixed">
            <summary>Перемешивать содержимое при выдаче массива элементов</summary>
        </member>
        <member name="F:MathService.Values.SetOf`1.f_List">
            <summary>Список элементов</summary>
        </member>
        <member name="P:MathService.Values.SetOf`1.Power">
            <summary>Мощность множества</summary>
        </member>
        <member name="M:MathService.Values.SetOf`1.#ctor">
            <summary>Новое множество элементов</summary>
        </member>
        <member name="M:MathService.Values.SetOf`1.#ctor(System.Int32)">
            <summary>Новое множество элементов</summary>
            <param name="Capacity">Ёмкость множества</param>
        </member>
        <member name="M:MathService.Values.SetOf`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Новое множество элементов</summary>
            <param name="collection">Коллекция элементов</param>
        </member>
        <member name="M:MathService.Values.SetOf`1.#ctor(`0[])">
            <summary>Новое множество элементов</summary>
            <param name="element">Элементы множества</param>
        </member>
        <member name="M:MathService.Values.SetOf`1.ToList">
            <summary>Преобразование в список</summary>
            <returns>Список элементов</returns>
        </member>
        <member name="M:MathService.Values.SetOf`1.ToArray">
            <summary>Преобразование множества элементов в массив</summary>
            <returns>Массив элементов</returns>
        </member>
        <member name="M:MathService.Values.SetOf`1.Clone">
            <summary>Клонирование множества элементов</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.Values.SetOf`1.GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.Values.SetOf`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Values.SetOf`1.Add(`0)">
            <summary>Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Values.SetOf`1.Clear">
            <summary>Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения. </exception>
        </member>
        <member name="M:MathService.Values.SetOf`1.Contains(`0)">
            <summary>
            Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathService.Values.SetOf`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">
            Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.
            </param>
            <param name="arrayIndex">
            Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.
            </param>
            <exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex"/> меньше 0.</exception>
            <exception cref="T:System.ArgumentException">
            Массив <paramref name="array"/> является многомерным.
              -или- Значение индекса массива <paramref name="arrayIndex"/> больше или равно длине массива <paramref name="array"/>.
              -или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="arrayIndex"/> и до конца массива назначения <paramref name="array"/>.
              -или-Тип не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:MathService.Values.SetOf`1.Remove(`0)">
            <summary>
            Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathService.Values.SetOf`1.System#Collections#Generic#ICollection{T}#Count">
            <summary>
            Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:MathService.Values.SetOf`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.
            </summary>
            <returns>
            Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.
            </returns>
        </member>
        <member name="T:MathService.Values.StreamDataSpeedValue">
            <summary>Измеритель скорости потока данных</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue.sf_DataNames">
            <summary>Названия скоростей</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.Now">
            <summary>Текущее время</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue.f_AverageValue">
            <summary>Значение, усреднённое во времени</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue.f_DataStream">
            <summary>Поток данных</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue.f_LastPosition">
            <summary>Последнее положение в потоке денных</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue.f_LastTime">
            <summary>Последнее время</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue.f_Round">
            <summary>Количество знаков после запятой в строковом представлении</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue.f_LastSpeedValue">
            <summary>Последнее зафиксированное значение скорости</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue.f_SpeedCheckTimeout">
            <summary>Минимально допустимый интервал времени в секундах для проверки значения скорости</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.Round">
            <summary>Количество знаков после запятой в строковом представлении</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.Value">
            <summary>Мгновенное значение скорости</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.AverageValue">
            <summary>Усреднённое значение скорости</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.SpeedStr">
            <summary>Строковое представление скорости</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.AverageTau">
            <summary>Постоянная времени усреднения </summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.SpeedCheckTimeout">
            <summary>Минимально домустимый интервал времени проверки скорости</summary>
        </member>
        <member name="M:MathService.Values.StreamDataSpeedValue.#ctor(System.IO.Stream)">
            <summary>Новый измеритель скорости потока данных</summary>
            <param name="DataStream">Поток данных для измерения</param>
            <exception cref="T:System.ArgumentNullException">Исключение возникает при нуливой ссылке на поток данных</exception>
        </member>
        <member name="M:MathService.Values.StreamDataSpeedValue.Reset">
            <summary>Сброс измерителя: установка стартового значения положения в потоке, сброс усреднителя</summary>
        </member>
        <member name="M:MathService.Values.StreamDataSpeedValue.CheckSpeed">
            <summary>Получить измерение скорости</summary>
            <returns>Мгновенная измеренная скорость перемещения в потоке</returns>
        </member>
        <member name="M:MathService.Values.StreamDataSpeedValue.op_Implicit(MathService.Values.StreamDataSpeedValue)~System.Double">
            <summary>Неявное преобразование измерителя скорости к значению скорости (усреднённому)</summary>
            <param name="speed">Измеритель скорости</param>
            <returns>Значение скосроти</returns>
        </member>
        <member name="M:MathService.Values.TimeAverage2Value.Add(System.Double)">
            <summary>Добавить значение</summary><param name="value">Значение</param>
        </member>
        <member name="T:MathService.Values.TimeAverageValue">
            <summary>Усредняемая по времени величина</summary>
        </member>
        <member name="F:MathService.Values.TimeAverageValue.f_LastTime">
            <summary>Последнее время доступа</summary>
        </member>
        <member name="F:MathService.Values.TimeAverageValue.f_Tau">
            <summary>Постоянная времени усреднения</summary>
        </member>
        <member name="P:MathService.Values.TimeAverageValue.Tau">
            <summary>Постоянная времени</summary>
        </member>
        <member name="P:MathService.Values.TimeAverageValue.Value">
            <summary>Значение</summary>
        </member>
        <member name="P:MathService.Values.TimeAverageValue.Initialized">
            <summary>Признак инициализации</summary>
        </member>
        <member name="M:MathService.Values.TimeAverageValue.#ctor(System.Double)">
            <summary>Усредняемая по времени величина</summary>
            <param name="tau">Постоянная времени усреднения >= 0</param>
        </member>
        <member name="M:MathService.Values.TimeAverageValue.#ctor(System.Double,System.Double)">
            <summary>Усредняемая по времени величина</summary>
            <param name="Value">Начальное значение</param><param name="tau">постоянная времени >= 0</param>
        </member>
        <member name="M:MathService.Values.TimeAverageValue.Add(System.Double)">
            <summary>Добавить значение</summary>
            <param name="value">Значение</param>
        </member>
        <member name="M:MathService.Values.TimeAverageValue.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="T:MathService.Values.AverageValue">
            <summary>Усредняемое значение</summary>
        </member>
        <member name="F:MathService.Values.AverageValue.f_N">
            <summary>Номер итерации усреднения</summary>
        </member>
        <member name="F:MathService.Values.AverageValue.f_Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="P:MathService.Values.AverageValue.Length">
            <summary>Размер окна усреднения</summary>
        </member>
        <member name="P:MathService.Values.AverageValue.Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="P:MathService.Values.AverageValue.StartEmpty">
            <summary>
            </summary>
        </member>
        <member name="M:MathService.Values.AverageValue.#ctor(System.Int32)">
            <summary>Новая усредняемая величина</summary>
            <param name="Length">Размер окна усреднения</param>
        </member>
        <member name="M:MathService.Values.AverageValue.#ctor(System.Double)">
            <summary>Новая усредняемая величина</summary>
            <param name="StartValue">Начальное значение для усреднения</param>
        </member>
        <member name="M:MathService.Values.AverageValue.#ctor(System.Double,System.Int32)">
            <summary>Новая усредняемая величина</summary>
            <param name="StartValue">Начальное значение</param>
            <param name="Length">Размер окна усреднения</param>
        </member>
        <member name="M:MathService.Values.AverageValue.AddValue(System.Double)">
            <summary>Добавить значение к усреднению</summary>
            <param name="value">Добавляемое значение</param>
        </member>
        <member name="M:MathService.Values.AverageValue.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathService.Values.AverageValue.ToString(System.String)">
            <summary>Преобразование в строку с форматированием</summary>
            <param name="Format">Формат</param>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathService.Values.AverageValue.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Новая усредняемая величина</summary>
            <param name="info">Сериализационная информация</param>
            <param name="context">Контекст сериализации</param>
        </member>
        <member name="T:MathService.Vectors.SpaceAngle">
            <summary>Пространственный угол</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle.c_ToDeg">
            <summary>Константа преобразования угла в радианах в градусы</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle.c_ToRad">
            <summary>Константа преобразования угла в градусах в радианы</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle.pi">
            <summary>Число Пи</summary>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.Random(System.Double,System.Double)">
            <summary>Случайный пространственный угол</summary>
            <param name="Min">Минимальное значение угла</param>
            <param name="Max">Максимальное значение угла</param>
            <returns>Случайный пространственный угол</returns>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle.f_AngleType">
            <summary>Тип угла</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle.f_Thetta">
            <summary>Угол места</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle.f_Phi">
            <summary>Угол азимута</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.Thetta">
            <summary>Угол места</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.Phi">
            <summary>Азимутальный угол в плоскости XOY</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.ComplexCosThetta">
            <summary>Комплексное число, характеризующее действительной частью направляющий косинус <see cref="P:MathService.Vectors.SpaceAngle.Thetta"/>, мнимой частью - направляющий синус</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.ComplexCosPhi">
            <summary>Комплексное число, характеризующее действительной частью направляющий косинус <see cref="P:MathService.Vectors.SpaceAngle.Phi"/>, мнимой частью - направляющий синус</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.AngleType">
            <summary>Тип угла</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.InDeg">
            <summary>Представление угла в градусах</summary>
            <exception cref="T:System.NotSupportedException" accessor="get">Неизвестный тип угла</exception>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.InRad">
            <summary>Представлкние угла в радианах</summary>
            <exception cref="T:System.NotSupportedException" accessor="get">Неизвестный тип угла</exception>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.#ctor(System.Double,System.Double)">
            <summary>Пространственный угол в радианах</summary>
            <param name="Thetta">Угол места [рад]</param>
            <param name="Phi">Азимутальный угол [рад]</param>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.#ctor(MathService.Vectors.SpaceAngle,MathService.AngleType)">
            <exception cref="T:System.NotSupportedException">Если AngleType != Deg || Rad - Неизвестный тип угла</exception>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.Rotate_PhiThetta(System.Double,System.Double,MathService.AngleType)">
            <summary>Повернуть угол в сферической системе координат</summary>
            <param name="thetta">Угол места поворота локальной системы кординат</param>
            <param name="phi">Угол азимута поворота локальной системы координат</param>
            <param name="type">Тип значений угловых величин</param>
            <returns>Угол в повёрнутой локальной системе координат</returns>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.Rotate_PhiThetta(MathService.Vectors.SpaceAngle)">
            <summary>Повернуть угол в сферической системе координат</summary>
            <param name="angle">Пространственный угол поворота локаьлной системы координат</param>
            <returns>Угол в повёрнутой локальной системе координат</returns>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.op_ExclusiveOr(System.Func{MathService.Vectors.SpaceAngle,System.Double},MathService.Vectors.SpaceAngle)">
            <summary>Оператор поворота функции на пространственный угол</summary>
            <param name="f">Вещественная пространственная функция</param>
            <param name="a">Пространственный угол поворота</param>
            <returns>Вещественная функция, аргумент которой повёрнут на указанный пространственный угол</returns>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.op_ExclusiveOr(System.Func{MathService.Vectors.SpaceAngle,MathService.Complex},MathService.Vectors.SpaceAngle)">
            <summary>Оператор поворота функции на пространственный угол</summary>
            <param name="f">Комплексная пространственная функция</param>
            <param name="a">Пространственный угол поворота</param>
            <returns>Комплексная функция, аргумент которой повёрнут на указанный пространственный угол</returns>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.ComparisonsAccuracy">
            <summary>Точность сравнения (по умолчанию 10^-13)</summary>
        </member>
        <member name="T:MathService.Vectors.Vector3D">
            <summary>Трёхмерный вектор</summary>
        </member>
        <member name="M:MathService.Vectors.Vector3D.Product_Scalar(MathService.Vectors.Vector3D)">
            <summary>Скалярное произведение векторов</summary>
            <param name="Vector">Вектор, на который домножается текущий вектор</param>
            <returns>Число, равное скалярному произведению векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.Product_Mixed(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Смешанное произведение трёх векторов</summary>
            <param name="A">Первый вектор произведения</param>
            <param name="B">Второй вектор произведения</param>
            <param name="C">Третий вектор произведения</param>
            <returns>Число, равное смешанному произведения векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.Product_Vector(MathService.Vectors.Vector3D)">
            <summary>Векторное произведение векторов</summary>
            <param name="Vector">Вектор, на который домножается исходный вектор</param>
            <returns>Вектор, равный векторному произведению векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.Product_Component(MathService.Vectors.Vector3D)">
            <summary>Покомпонентное домножение на вектор</summary>
            <param name="Vector">Векторный сомножитель</param>
            <returns>Вектор, компоненты которого являются произведениями компоненты векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.GetAngle(MathService.Vectors.Vector3D)">
            <summary>Угол между векторами</summary>
            <param name="Vector">Вектор, к которорому вычисляется угол</param>
            <returns>Пространственный угол между векторами</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.GetProjectionTo(MathService.Vectors.Vector3D)">
            <summary>Проекция на вектор</summary>
            <param name="Vector">Вектор, НА который производится проекция</param>
            <returns>Проекция на вектор</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.GetProjectionTo(MathService.Vectors.SpaceAngle)">
            <summary>Проекция на наравление</summary>
            <param name="Direction">Направление, на которое проектируется вектор</param>
            <returns>Проекция вектора на направление</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_Multiply(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Скалярное произведение векторов</summary>
            <param name="A">Первый вектор-множитель</param>
            <param name="B">Второй вектор-множитель</param>
            <returns>Число - скалярное произведение векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_ExclusiveOr(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Угол между векторами</summary>
            <param name="A">Вектор 1</param>
            <param name="B">Вектор 2</param>
            <returns>Угол между вектором А и вектором В в пространстве</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_BitwiseOr(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Проверка на параллельность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_BitwiseAnd(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Проверка на ортогональность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектор 1 ортогонален вектору 2</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_Modulus(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Проекция вектора A на вектор B</summary>
            <param name="A">Проецируемый вектор</param>
            <param name="B">Вектор, на который производится проекция</param>
            <returns>Проекция вектора А на вектор В</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_Modulus(MathService.Vectors.Vector3D,MathService.Vectors.SpaceAngle)">
            <summary>Проекция вектора на направление</summary>
            <param name="Vector">Проецируемый вектор</param>
            <param name="Direction">Пространственный угол направления проекции</param>
            <returns>Вещественное значение проекции</returns>
        </member>
        <member name="P:MathService.Vectors.Vector3D.BasysUnitVector">
            <summary>Единичный базисный вектор</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.i">
            <summary>Базисный вектор i</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.j">
            <summary>Базисный вектор j</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.k">
            <summary>Базисный вектор k</summary>
        </member>
        <member name="F:MathService.Vectors.Vector3D.f_X">
            <summary>Длина по оси X</summary>
        </member>
        <member name="F:MathService.Vectors.Vector3D.f_Y">
            <summary>Длина по оси Y</summary>
        </member>
        <member name="F:MathService.Vectors.Vector3D.f_Z">
            <summary>Длина по оси Z</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.X">
            <summary>Длина по оси X</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Y">
            <summary>Длина по оси Y</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Z">
            <summary>Длина по оси Z</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.R">
            <summary>Длина вектора</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.AngleXOY">
            <summary>Угол проекции в плоскости XOY</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.AngleXOZ">
            <summary>Угол проекции в плоскости XOZ</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.AngleYOZ">
            <summary>Угол проекции в плоскости YOZ</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Phi">
            <summary>Азимутальный угол</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Thetta">
            <summary>Угол места</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Angle">
            <summary>Пространственный угол</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.VectorXOY">
            <summary>Двумерный вектор - проекция в плоскости XOY</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.VectorXOZ">
            <summary>Двумерный вектор - проекция в плоскости XOZ (X->X; Z->Y)</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.VectorYOZ">
            <summary>Двумерный вектор - проекция в плоскости YOZ (Y->X; Z->Y)</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.R_XOY">
            <summary>Длина в плоскости XOY</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.R_XOZ">
            <summary>Длина в плоскости XOZ</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.R_YOZ">
            <summary>Длина в плоскости YOZ</summary>
        </member>
        <member name="M:MathService.Vectors.Vector3D.System#ICloneable#Clone">
            <summary>Создает новый объект, который является копией текущего экземпляра.</summary>
            <returns>Новый объект, являющийся копией этого экземпляра.</returns><filterpriority>2</filterpriority>
        </member>
        <member name="P:MathService.Vectors.Vector3D.ComparisonsAccuracy">
            <summary>Точность сравнения (по умолчанию 10^-16)</summary>
        </member>
        <member name="T:MathService.Vectors.Vector2D">
            <summary>Двумерный вектор</summary>
        </member>
        <member name="F:MathService.Vectors.Vector2D.f_X">
            <summary>Координата X</summary>
        </member>
        <member name="F:MathService.Vectors.Vector2D.f_Y">
            <summary>Координата Y</summary>
        </member>
        <member name="P:MathService.Vectors.Vector2D.X">
            <summary>Координата X</summary>
        </member>
        <member name="P:MathService.Vectors.Vector2D.Y">
            <summary>Координата Y</summary>
        </member>
        <member name="P:MathService.Vectors.Vector2D.R">
            <summary>Радиус (длина) вектора</summary>
        </member>
        <member name="P:MathService.Vectors.Vector2D.Angle">
            <summary>Угол к оси X в радианах</summary>
        </member>
        <member name="M:MathService.Vectors.Vector2D.#ctor(System.Double,System.Double)">
            <summary>Инициализация двумерного вектора</summary>
            <param name="X">Координата X</param>
            <param name="Y">Координата Y</param>
        </member>
        <member name="M:MathService.Vectors.Vector2D.#ctor(MathService.Complex)">
            <summary>Инициализация вектора по по комплексному числу</summary>
            <param name="Z">Комплексное число X + iY</param>
        </member>
        <member name="M:MathService.Vectors.Vector2D.InBasis(MathService.Vectors.Basis2D)">
            <summary>Представление вектора в базисе</summary>
            <param name="b">Базис</param>
            <returns>Вектор в базисе</returns>
        </member>
        <member name="T:MathService.TypeDesigners.ITypeDesigner">
            <summary>Интерфейс редактора объекта</summary>
        </member>
        <member name="M:MathService.TypeDesigners.ITypeDesigner.Edit(System.Object)">
            <summary>Редактировать объект</summary>
            <param name="Item">Редактируемый объект</param>
        </member>
        <member name="M:MathService.TypeDesigners.ITypeDesigner`1.Edit(`0)">
            <summary>Редактировать объект</summary>
            <param name="Item">Редактируемый объект</param>
        </member>
        <member name="T:MathService.Polynom">
            <summary>
            Полином степени N-1
             a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)
            где N - число элементов массива коэффициентов
            Нулевой элемент массива при нулевой степени члена полинома 
            </summary>
        </member>
        <member name="M:MathService.Polynom.GetPowers(System.Double[])">
            <summary>Преобразовать массив корней полинома в коэффициенты прои степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при степенях</returns>
        </member>
        <member name="M:MathService.Polynom.Roots(System.Double[])">
            <summary>Получить полином из корней полинома</summary>
            <param name="Root">Корни полинома</param>
            <returns>Полином с указанными корнями</returns>
        </member>
        <member name="F:MathService.Polynom.f_a">
            <summary>Коэффициенты при степенях</summary>
            <remarks>a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</remarks>
        </member>
        <member name="P:MathService.Polynom.Coefficients">
            <summary>
            Коэффициенты при степенях
              a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)
            </summary>
        </member>
        <member name="P:MathService.Polynom.Power">
            <summary>Степень полинома = число коэффициентов - 1</summary>
        </member>
        <member name="P:MathService.Polynom.Length">
            <summary>Длина полинома - число коэффициентов</summary>
        </member>
        <member name="P:MathService.Polynom.Item(System.Int32)">
            <summary>
             Коэффициент при степени <paramref name="n"/>, где <paramref name="n"/> принадлежит [0; <see cref="P:MathService.Polynom.Power"/>]
             <see cref="P:MathService.Polynom.Power"/> = <see cref="P:MathService.Polynom.Length"/> - 1
             </summary>
            <param name="n">Степень a[0]+a[1]*x+a[2]*x^2+...<b>+a[<paramref name="n"/>]*x^<paramref name="n"/>+</b>...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</param>
        </member>
        <member name="M:MathService.Polynom.#ctor(System.Double[])">
            <summary>Полином степени N, нулевой элемент массива a[0] при младшей степени x^0</summary>
            <param name="a">a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</param>
        </member>
        <member name="M:MathService.Polynom.Value(System.Double)">
            <summary>Получить значение полинома</summary>
            <param name="x">Переменная</param>
            <returns>Значение полинома в точке x</returns>
        </member>
        <member name="M:MathService.Polynom.op_Implicit(MathService.Polynom)~System.Func{System.Double,System.Double}">
            <summary>Явное приведение типов полинома к делегату функции преобразования double->double</summary>
            <param name="P">Полином</param>
            <returns>Делегат функции преобразования</returns>
        </member>
        <member name="M:MathService.Polynom.op_Addition(MathService.Polynom,MathService.Polynom)">
            <summary>Оператор сложения двух полиномов</summary>
            <param name="P">Первое слагаемое</param>
            <param name="Q">Второе слагаемое</param>
            <returns>Сумма полиномов</returns>
        </member>
        <member name="M:MathService.Polynom.op_UnaryNegation(MathService.Polynom)">
            <summary>
            Оператор отрицания полинома (изменяет знак всех коэффициентов на обратной). Эквивалентно домножению полинома на -1
            </summary>
            <param name="P">Отрицаемый полином</param>
            <returns>Полином Q = -P</returns>
        </member>
        <member name="M:MathService.Polynom.op_Subtraction(MathService.Polynom,MathService.Polynom)">
            <summary>Оператор вычетания полинома Q из полинома P</summary>
            <param name="P">Уменьшаемое</param>
            <param name="Q">Вычитаемое</param>
            <returns>Разность</returns>
        </member>
        <member name="T:MathService.Polynom.PolynomDevisionResult">
            <summary>Результат деления полиномов</summary>
        </member>
        <member name="F:MathService.Polynom.PolynomDevisionResult.Result">
            <summary>Частное полиномов</summary>
        </member>
        <member name="F:MathService.Polynom.PolynomDevisionResult.Remainder">
            <summary>Остаток деления полиновов</summary>
        </member>
        <member name="M:MathService.Polynom.PolynomDevisionResult.#ctor(MathService.Polynom,MathService.Polynom,MathService.Polynom)">
            <summary>Инициализация результата деления полиномов</summary>
            <param name="Divisor"></param>
            <param name="Result">Частоное</param>
            <param name="Remainder">Остаток от деления</param>
        </member>
        <member name="M:MathService.Polynom.PolynomDevisionResult.op_Implicit(MathService.Polynom.PolynomDevisionResult)~MathService.Polynom">
            <summary>Оператор неявного преобразования результата деления полиномов в полином результата</summary>
            <param name="Result">Результат деления полиномов</param>
            <returns>Частное</returns>
        </member>
        <member name="M:MathService.Polynom.op_Division(MathService.Polynom,MathService.Polynom)">
            <summary>Оператор деления двух полиномов</summary>
            <param name="p">Полином делимого</param>
            <param name="q">Полином делителя</param>
            <returns>Результат деления полиномов, включающий частное и остаток от деления</returns>
        </member>
        <member name="M:MathService.Polynom.op_Explicit(MathService.Polynom)~System.Double[]">
            <summary>Оператор неявного преведения типа полинома в массив вещественных значений коэффициентов</summary>
            <param name="p">Полином</param>
            <returns>Массив значений коэффициентов</returns>
        </member>
        <member name="M:MathService.Polynom.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Polynom.System#Collections#Generic#IEnumerable{System#Double}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="T:MathService.XmInitializer`1">
            <summary>Инициализатор объекта по структуре xml-файла</summary>
            <typeparam name="TObject">Тип инициализируемого объекта</typeparam>
        </member>
        <member name="T:MathService.XmInitializer`1.Rule">
            <summary>Правило инициализации</summary>
        </member>
        <member name="F:MathService.XmInitializer`1.Rule.f_XPath">
            <summary>XPath-выражение - путь в структуре xml</summary>
        </member>
        <member name="F:MathService.XmInitializer`1.Rule.f_PropertyBody">
            <summary>Выражение, применяемое при обнаружении значения указанного XPath-пути</summary>
        </member>
        <member name="F:MathService.XmInitializer`1.Rule.f_Update">
            <summary>Скомпилированный метод инициализации</summary>
        </member>
        <member name="P:MathService.XmInitializer`1.Rule.UpdateExpression">
            <summary>Выражение, применяемое при обнаружении значения указанного XPath-пути</summary>
        </member>
        <member name="P:MathService.XmInitializer`1.Rule.XPath">
            <summary>XPath-выражение - путь в структуре xml</summary>
        </member>
        <member name="P:MathService.XmInitializer`1.Rule.Update">
            <summary>Скомпилированный метод инициализации</summary>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`0,System.String}},System.Boolean)">
            <summary>Инициализация нового правила</summary>
            <param name="XPath">XPath-путь в структуре xml</param>
            <param name="Expression">Выражение инициализации</param>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule.Execute(`0,System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Выполнить инициализацию</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="e">Корень структуры xml</param>
            <param name="ns">Описание пространств имён</param>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule.Execute(System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Выполнить инициализацию</summary>
            <param name="e">Корень структуры xml</param>
            <param name="ns">Описание пространств имён</param>
        </member>
        <member name="T:MathService.XmInitializer`1.Rule`1">
            <summary>Типизированное правило инициализации</summary>
            <typeparam name="TValue">Тип значения инициализируемого параметра объекта</typeparam>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule`1.GetExpression(System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Получить выражение инициализации для выражения определения свойства</summary>
            <param name="expression">Выражение определения инициализируемого параметра объекта</param>
            <param name="converter">Выражение преобразования строки в тип объекта</param>
            <returns>Выражение инициализации, как процедура с параметром - объектом и строкой xml-узла</returns>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule`1.GetExpression(System.Linq.Expressions.Expression{System.Action{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Получить выражение инициализации объекта по выражению инициализации и выражению конвертера</summary>
            <param name="expression">Выражение инициализации</param>
            <param name="converter">Конвертер преобразования строки в нужный тип данных</param>
            <returns>Выражение инициализации объекта по строке xml-структуры</returns>
        </member>
        <member name="M:MathService.XmInitializer`1.Initialize(`0,System.Xml.XmlReader)">
            <devdoc>
                <para>
                    Gets the type of the current node.
                </para>
            </devdoc>
        </member>
        <member name="M:MathService.XmInitializer`1.Add``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{System.String,``0}})">
            <summary>Добавить правило с указанием выражения получения члена объекта</summary>
            <typeparam name="TPropertyValue">Тип значения свойства</typeparam>
            <param name="path">Путь в xml-структуре</param>
            <param name="expr">Выражение, определяющее член объекта</param>
            <param name="conv">Выражение преобразования строки в целевой тип данных</param>
        </member>
        <member name="M:System.ActionsCollectionProcessor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="T:System.NotSupportedAttribute">
            <summary>Атрибут признака неподдерживаемости</summary>
        </member>
        <member name="P:System.NotSupportedAttribute.Message">
            <summary>Сообщение</summary>
        </member>
        <member name="M:System.NotSupportedAttribute.#ctor">
            <summary>Новый атрибут неподдерживаемости</summary>
        </member>
        <member name="M:System.NotSupportedAttribute.#ctor(System.String)">
            <summary>Новый атрибут неподдерживаемости</summary>
            <param name="Message">Сообщение (почему не поддерживается?)</param>
        </member>
        <member name="M:System.NotSupportedAttribute.IsDefaultAttribute">
            <summary>Признак атрибута "по умолчанию"</summary>
            <returns>Истина, если указан незаполненный атрибут</returns>
        </member>
        <member name="T:System.Linq.Expressions.ExpressionMatrix">
            <summary>Матрица NxM</summary>
            <remarks>
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix.f_N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix.f_M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix.f_Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце) 0..N-1</param>
            <param name="j">Номер столбца (элемента в строке) 0..M-1</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Linq.Expressions.Expression})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Linq.Expressions.Expression})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTransvection(System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="col">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.System#ICloneable#Clone">
            <summary> Создает новый объект, который является копией текущего экземпляра</summary>
            <returns> Новый объект, являющийся копией этого экземпляра </returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Addition(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Subtraction(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Multiply(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Division(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_BitwiseOr(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Implicit(System.Linq.Expressions.Expression)~System.Linq.Expressions.ExpressionMatrix">
            <summary>Оператор неявного преведения типа вещественного числа двойной точнойсти к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:System.Linq.Expressions.ExpressionRebuilder">
            <summary>Пересборщик дерева выражения Linq.Expression</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.InvokeEvent``1(System.EventHandlerReturn{System.EventArgs{``0},System.Linq.Expressions.Expression},``0,System.Func{``0,System.Linq.Expressions.Expression})">
            <summary>Метод генерации события посещения узла типа Expression</summary>
            <typeparam name="TExpressionNode">Тип узла дерева</typeparam>
            <param name="Handlers">Событие</param>
            <param name="Node">Узел дерева</param>
            <param name="Base">Базовый метод обработки узла</param>
            <returns>Узел, которым надо заместить посещённый узел дерева</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.InvokeEvent``2(System.EventHandlerReturn{System.EventArgs{``1},``1},``0,System.Func{``0,``1})">
            <summary>Метод генерации события посещения узла произвольного типа</summary>
            <typeparam name="TElement">Тип узла дерева</typeparam><typeparam name="TOut">Тип выходного узла</typeparam>
            <param name="Handlers">Событие</param>
            <param name="Node">Посещённый узел дерева</param>
            <param name="Base">Базовый метод обработки узла</param>
            <returns>Узел, которым надо заместить посещённый узел дерева</returns>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.Visited">
            <summary>Событие возникает при посещении любого узла дерева</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.Visit(System.Linq.Expressions.Expression)">
            <summary>Посетить узел дерева</summary><param name="Node">Узел дерева</param><returns>Новый узел дерева</returns>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BinaryVisited">
            <summary>Событие возникает при посещении узла дерева бинарного выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BindingVisited">
            <summary>Событие возникает при посещении узла привязки</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BindingListVisited">
            <summary>Событие возникает при посещении коллекции привязки</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ConditionalVisited">
            <summary>Событие возникает при посещении узла условного оператора</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ConstantlVisited">
            <summary>Событие возникает при посещении узла константы</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ElementInitializerVisited">
            <summary>Событие возникает при посещении узла инициализатора объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ElementInitializerListVisited">
            <summary>Событие возникает при посещении коллекции инициализаторов объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ExpressionListVisited">
            <summary>Событие возникает при посещении коллекции выражений</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.LambdaVisited">
            <summary>Событие возникает при посещении лямда-выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ListInitVisited">
            <summary>Событие возникает при посещении узла инициализатора коллекции</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.InvocationVisited">
            <summary>Событие возникает при посещении узла вызова функции</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberAccessVisited">
            <summary>Событие возникает при посещении узла доступа к члену объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberAssignmentVisited">
            <summary>Событие возникает при посещении узла присвоения члену объекта значения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberInitVisited">
            <summary>Событие возникает при посещении узла инициализатора свойства объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberListBindingVisited">
            <summary>Событие возникает при посещении узла инициализатора коллекции объектов</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberMemberBindingVisited">
            <summary>Событие возникает при посещении узла инициализатора элементов элемента</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MethodCallVisited">
            <summary>Событие возникает при посещении узла вызова метода</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.NewVisited">
            <summary>Событие возникает при посещении узла конструктора</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.NewArrayVisited">
            <summary>Событие возникает при посещении узла конструктора массива</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ParameterVisited">
            <summary>Событие возникает при посещении узла параметра выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.TypeIsVisited">
            <summary>Событие возникает при посещении узла определения типа выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.UnaryVisited">
            <summary>Событие возникает при посещении узла унарного выражения</summary>
        </member>
        <member name="T:System.Linq.Expressions.Property`1">
            <summary>Свойство класса</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
        </member>
        <member name="E:System.Linq.Expressions.Property`1.PropertyChanged">
            <summary>Событие изменения свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения свойства</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="F:System.Linq.Expressions.Property`1.f_PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property`1.f_Reader">
            <summary>Метод чтения свойства</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property`1.f_Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.CanRead">
            <summary>Признак возможности чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.CanWrite">
            <summary>Признак возможности записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Reader">
            <summary>Метод чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.DescriptionAttribute">
            <summary>Свойство доступа к значению аттрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.DisplayName">
            <summary>Отображаемое имя</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.IsNotifyPropertyChanged">
            <summary>Признак реализации объектом-хозяином свойства интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Type,System.String,System.Boolean)">
            <summary>Инициализация доступа к статическому свойству</summary>
            <param name="type">Рассматриваемый тип</param>
            <param name="Name">Имя статического свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Object,System.String,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="Name">Имя свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Object,System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="info">Информация о свойстве</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.LoadAttributes">
            <summary>Чтение сведений из аттрибутов</summary>
        </member>
        <member name="T:System.Linq.Expressions.Property">
            <summary>Свойство класса</summary>
        </member>
        <member name="E:System.Linq.Expressions.Property.PropertyChanged">
            <summary>Событие изменения свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения свойства</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="F:System.Linq.Expressions.Property.f_PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property.f_Reader">
            <summary>Метод чтения свойства</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property.f_Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.CanRead">
            <summary>Признак возможности чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.CanWrite">
            <summary>Признак возможности записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Reader">
            <summary>Метод чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.DescriptionAttribute">
            <summary>Свойство доступа к значению аттрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.DisplayName">
            <summary>Отображаемое имя</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.IsNotifyPropertyChanged">
            <summary>Признак реализации объектом-хозяином свойства интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Type,System.String,System.Boolean)">
            <summary>Инициализация доступа к статическому свойству</summary>
            <param name="type">Рассматриваемый тип</param>
            <param name="Name">Имя статического свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Object,System.String,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="Name">Имя свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Object,System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="info">Информация о свойстве</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.LoadAttributes">
            <summary>Чтение сведений из аттрибутов</summary>
        </member>
        <member name="T:System.Linq.Expressions.TeXEvaluationExpressionVisitor">
            <summary>
            Класс "посетителя" для "подстановки" актуальных значний в дерево выражения
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.MultiplicationSign">
            <summary>
            TeX supports several styles for multiplication sign
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.None">
            <summary>
            Without any sign
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.Asterisk">
            <summary>
            * sign
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.Times">
            <summary>
            x sign
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.TeXExpressionVisitor">
            <summary>
            Класс "посетилителя", который "изучает" дерево выражения путем переопределения соответствующих
            виртуальных методов базового класса System.Linq.Expressions.ExpressionVisitor
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.TeXExpressionVisitor.VisitPrefixBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Оператор деления \fract требует иного порядка аргументов:
            \frac{arg1}{arg2} 
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:System.Linq.Reactive.IObservableEx`1">
            <summary>Обозреваемый объект</summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="M:System.Linq.Reactive.IObservableEx`1.Subscribe(System.Linq.Reactive.IObserverEx{`0})">
            <summary>Метод получения наблюдателя</summary>
            <param name="observer">Наблюдатель объекта</param>
            <returns>Объект, реализующий возможность разрушшения связи с наблюдаемым объектом</returns>
        </member>
        <member name="T:System.Linq.Reactive.IObserverEx`1">
            <summary>Интерфейс наблюдателя</summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Next">
            <summary>Событие появления следующего объекта последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Complited">
            <summary>Событие завершения последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Reset">
            <summary>Событие сброса последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Error">
            <summary>Событие появления исключения</summary>
        </member>
        <member name="M:System.Linq.Reactive.IObserverEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="T:System.Linq.Reactive.ObservableExtentions">
            <summary>Методы-расширения интерфейса наблюдаемых объектов <see cref="T:System.Linq.Reactive.IObservableEx`1"/></summary>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.FromProperty``1(System.ComponentModel.INotifyPropertyChanged,System.String)">
            <summary>Метод получения наблюдаемого объекта для объекта, реализующего интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>  для указанного имени свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="obj">Наблюдаемый объект</param>
            <param name="ProperyName">Имя свойства</param>
            <returns>Объект-наблюдатель за свойством</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>Метод фильтрации событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="observable">Исходный объект-наблюдатель</param>
            <param name="Predicate">Метод фильтрации</param>
            <returns>Объекнаблюдатель с установленным методом фильтрации</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>Метод фильтрации событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="observable">Исходный объект-наблюдатель</param>
            <param name="Predicate">Метод фильтрации</param>
            <param name="ElseAction">Метод обработки невошедших событий</param>
            <returns>Объекнаблюдатель с установленным методом фильтрации</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Select``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>Метод преобразования объектов событий</summary>
            <typeparam name="T">Тип исходных объектов событий</typeparam>
            <typeparam name="Q">Тип результирующих объектов событий</typeparam>
            <param name="observable">Исходный объект-наблюдатель</param>
            <param name="Selector">Объект-наблюдатель с преобразованными объектами событий</param>
            <returns>Объект-наблюдатель с преобразованными типами объектов</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.WhaitSync``1(System.IObservable{``0},System.TimeSpan)">
            <summary>Метод получения синхронно задержанных во времени событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Interval">Интервал времени задержки событий</param>
            <returns>ОБъект-наблюдатель, события которого синхронно задержаны во времени на указанный интервал</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.WhaitAsync``1(System.IObservable{``0},System.TimeSpan)">
            <summary>Метод получения задержанных во времени событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Interval">Интервал времени задержки событий</param>
            <returns>ОБъект-наблюдатель, события которого задержаны во времени на указанный интервал</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.FromEvent``1(System.Object,System.String)">
            <summary>Метод получения объекта-наблюдателя для указанного события</summary>
            <typeparam name="TEventArgs">Тип аргументов события</typeparam>
            <param name="Obj">Наблюдаемый объект</param>
            <param name="EventName">Имя события</param>
            <returns>Объект-ниблюдатель за событием</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.GetObservable``1(System.Collections.Generic.IEnumerable{``0},System.IObservable{``0}@)">
            <summary>Метод получения объекта-наблюдателя из объекта-перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="collection">Перечисление объектов</param>
            <param name="observable">Созданный объект-наблюдатель за перечислением объектов коллекции</param>
            <returns>Новое перечисление объектов, перечисление объектов которого вызывает события в наблюдателе</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Take``1(System.IObservable{``0},System.Int32)">
            <summary>Метод получения объекта-нибулюдателя, пропускающего после создания указанное число событий</summary>
            <typeparam name="T">Тип объектов события</typeparam>
            <param name="observable">Исходный объект-наблюдатель</param>
            <param name="Count">Количество пропускаемых событий</param>
            <returns>Объект-наблюдатель с указанным количеством пропускаемых событий</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Take``3(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.Boolean)">
            <summary>Метод обработки последовательности событий с учётом разрешающей и запрещающей последовательностей</summary>
            <typeparam name="T">Тип объектов событий наблюдаемого объекта</typeparam>
            <typeparam name="O">Тип объектов событий разрешающей последовательности</typeparam>
            <typeparam name="C">Тип объектов событий запрещающей последовательности</typeparam>
            <param name="source">Объект-наблюдатель источник событий</param>
            <param name="Open">Объект-наблюдатель разрешающий событий в выходной последовательности</param>
            <param name="Close">Объект-наблюдатель запрещающий событий в выходной последовательности</param>
            <param name="IsOpen">Исходное состояния разрешения событий в выходной последовательности (по умолчанию разрешено)</param>
            <returns>Управляемый объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.TakeUntil``2(System.IObservable{``0},System.IObservable{``1},System.Boolean)">
            <summary>Метод получения объекта-наблюдателя, события в котором пропускаются в выходную последовательность только до появления события в управляющей последовательности</summary>
            <typeparam name="T">Тип исходных объектов события</typeparam>
            <typeparam name="Q">Тип события управляющей последовательности</typeparam>
            <param name="source">Исходный объект-наблюдатель</param>
            <param name="Selector">Обект-наблюдатель управляющей последовательности</param>
            <param name="IsOpen">Исходное состояние выходной последовательности</param>
            <returns>Объект-наблюдатель управляемый управляющей последовательностью</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.SkipWhile``2(System.IObservable{``0},System.IObservable{``1},System.Boolean)">
            <summary>Метод получения объекта-наблюдателя, события в котором пропускаются в выходную последовательность только после появления события в управляющей последовательности</summary>
            <typeparam name="T">Тип исходных объектов события</typeparam>
            <typeparam name="Q">Тип события управляющей последовательности</typeparam>
            <param name="source">Исходный объект-наблюдатель</param>
            <param name="Selector">Обект-наблюдатель управляющей последовательности</param>
            <param name="IsOpen">Исходное состояние выходной последовательности</param>
            <returns>Объект-наблюдатель управляемый управляющей последовательностью</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.ForeachAction``1(System.IObservable{``0},System.Action{``0})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.ForeachAction``1(System.IObservable{``0},System.Action{``0},System.Func{``0,System.Boolean})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <param name="where">Метод выборки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.ForeachAction``1(System.IObservable{``0},System.Action{``0,System.Int32})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.ForeachAction``1(System.IObservable{``0},System.Action{``0,System.Int32},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <param name="where">Метод выборки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.OnError``1(System.IObservable{``0},System.Action{System.Exception})">
            <summary>Метод обработки события <see cref="T:System.Exception"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="OnError">Метод обработки события <see cref="T:System.Exception"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.OnComplited``1(System.IObservable{``0},System.Action)">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Complited"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="OnComplited">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Complited"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.OnReset``1(System.IObservable{``0},System.Action)">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Reset"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="OnReset">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Reset"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.SelectMany``1(System.IObservable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Метод-лианиризатор событий для наблюдаемого объекта, возвращающего коллекцию объектов типа <see cref="!:T"/></summary>
            <typeparam name="T">Тип результирующих объектов</typeparam>
            <param name="o">Объект-наблюдатель коллекции</param>
            <returns>Объект-наблюдатель элементов коллекции</returns>
        </member>
        <member name="T:System.Linq.Reactive.ObservableExContract`1">
            <summary>Класс контрактов для интерфейса <see cref="T:System.Linq.Reactive.IObservableEx`1"/></summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="T:System.Linq.Reactive.SimpleObservableEx`1">
            <summary>Простейший наблюдаемый объект</summary><typeparam name="T">Тип объектов событий</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.SimpleObservableEx`1.f_Observers">
            <summary>Список объектов наблюдателей</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnNext(`0)">
            <summary>Метод генерации следующего события</summary>
            <param name="item">Объект события</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnCompleted">
            <summary>Метод генерации события завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnError(System.Exception)">
            <summary>Метод генерации события возникновения ошибки</summary>
            <param name="error">Возникшая ошибка</param>
        </member>
        <member name="T:System.Linq.Reactive.SimpleObserverEx`1">
            <summary>Простейший наблюдатель</summary>
            <typeparam name="T">Объект события</typeparam>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Next">
            <summary>События появления следующего объекта в последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Complited">
            <summary>Событие завершения последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Reset">
            <summary>Событие сброса последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Error">
            <summary>Событие появления исключения</summary>
        </member>
        <member name="P:System.Linq.Reactive.SimpleObserverEx`1.Tag">
            <summary>Тэг наблюдателя</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.#ctor(System.IObservable{`0})">
            <summary>Инициализация нового простейшего наблюдателя</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnNext(`0)">
            <summary>Метод генерации события появления следующего объекта</summary>
            <param name="item">Следующий объект в последовательности</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnError(System.Exception)">
            <summary>Метод генерации события исключительной ситуации</summary>
            <param name="error">Исключительная ситуация</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnCompleted">
            <summary>Метод генерации события завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="T:System.Linq.Reactive.TakeObservable`1">
            <summary>Наблюдаемый объект с указанным числом генерации событий</summary>
            <typeparam name="T">Тип объектов последовательности</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.TakeObservable`1.f_Observer">
            <summary>Исходный наблюдатель</summary>
        </member>
        <member name="M:System.Linq.Reactive.TakeObservable`1.#ctor(System.IObservable{`0},System.Int32)">
            <summary>Наблюдаемый объект с указанным числом генерации событий</summary>
            <param name="observable">Исходный наблюдаемый объект</param>
            <param name="Count">Количество извлекаемых событий</param>
        </member>
        <member name="T:System.Linq.Reactive.TriggeredObservable`1">
            <summary>Управляемый наблюдаемый объект</summary>
            <typeparam name="T">Тип объекта последовательности</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.TriggeredObservable`1.f_Observer">
            <summary>Наблюдатель</summary>
        </member>
        <member name="P:System.Linq.Reactive.TriggeredObservable`1.Open">
            <summary>Признак разрешения генерации событий</summary>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.#ctor(System.IObservable{`0},System.Boolean)">
            <summary>Управляемый наблюдаемый объект</summary>
            <param name="observable">Наблюдаемый объект</param>
            <param name="IsOpen">Исходное состояние</param>
        </member>
        <member name="T:System.Linq.Reactive.Unit">
            <summary>
            Represents a type with a single value. This type is often used to denote the successful completion of a void-returning method (C#) or a Sub procedure (Visual Basic).
            
            </summary>
        </member>
        <member name="P:System.Linq.Reactive.Unit.Default">
            <summary>
            Gets the single unit value.
            
            </summary>
        </member>
        <member name="M:System.Linq.Reactive.Unit.op_Equality(System.Linq.Reactive.Unit,System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the two specified Unit values are equal. Because Unit has a single value, this always returns true.
            
            </summary>
            <param name="first">The first Unit value to compare.</param><param name="second">The second Unit value to compare.</param>
            <returns>
            Because Unit has a single value, this always returns true.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.op_Inequality(System.Linq.Reactive.Unit,System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the two specified Unit values are not equal. Because Unit has a single value, this always returns false.
            
            </summary>
            <param name="first">The first Unit value to compare.</param><param name="second">The second Unit value to compare.</param>
            <returns>
            Because Unit has a single value, this always returns false.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.Equals(System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the specified Unit values is equal to the current Unit. Because Unit has a single value, this always returns true.
            
            </summary>
            <param name="other">An object to compare to the current Unit value.</param>
            <returns>
            Because Unit has a single value, this always returns true.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current Unit.
            
            </summary>
            <param name="obj">The System.Object to compare with the current Unit.</param>
            <returns>
            true if the specified System.Object is a Unit value; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.GetHashCode">
            <summary>
            Returns the hash code for the current Unit value.
            
            </summary>
            
            <returns>
            A hash code for the current Unit value.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.ToString">
            <summary>
            Returns a string representation of the current Unit value.
            
            </summary>
            
            <returns>
            String representation of the current Unit value.
            </returns>
        </member>
        <member name="T:System.Collections.Generic.IDictionaryExtentions">
            <summary>Класс методов-расширений для интерфейса <see cref="T:System.Collections.Generic.IDictionary`2"/></summary>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.AddValue``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}},``0,``1)">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="key">Ключ словаря типа <typeparamref name="TKey"/></param>
            <param name="value">Значение списка типа <typeparamref name="TValue"/></param>
            <typeparam name="TKey">Тип ключа словаря <paramref name="key"/></typeparam>
            <typeparam name="TValue">Тип значения списка значений <paramref name="value"/></typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.AddValue``3(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``2}},``1,System.Func{``1,``0},System.Func{``1,``2})">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="obj">Объект-ключ словаря типа <typeparamref name="TObject"/></param>
            <param name="KeySelector">Метод образования ключа типа <typeparamref name="TKey"/> словаря из объекта типа <typeparamref name="TObject"/></param>
            <param name="ValueSelector">Метод образования значения типа <typeparamref name="TValue"/> из объекта типа <typeparamref name="TObject"/></param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TObject">Тип входного объекта</typeparam>
            <typeparam name="TValue">Тип значения списка</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.AddValue``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}},``1,System.Func{``1,``0})">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="value">Значение, записываемое в словарь</param>
            <param name="KeySelector">Метод извлечения ключа из указанного значения</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения списка</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.AddValues``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>Добавление значений в словарь</summary>
            <param name="dictionary">Словарь в который надо добавить значения</param>
            <param name="collection">Коллекция добавляемух значений</param>
            <param name="converter">Метод определения ключа словаря для каждого из элементов коллекции</param>
            <typeparam name="TKey">ТИп ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.GetValueOrAddNew``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.GetValueOrAddNew``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения по указанному ключу, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.GetValueOrAddNew``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.GetValueOrAddNew``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.GetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ, значение для которого требуется получить</param>
            <param name="DefaultValue">Значение по-умолчанию, которое будет добавлено в словарь с указанным ключём, если он отсутствует</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа, либо указанное значение по-умолчанию</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ, значение для которого требуется получить</param>
            <param name="DefaultValue">Значение по-умолчанию, которое будет добавлено в словарь с указанным ключём, если он отсутствует</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа, либо указанное значение по-умолчанию</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.GetValue``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="name">Название объекта, значение для которого требуется получить</param>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32,System.Func{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32,System.Func{System.Int32,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="keys">Коллекция ключей</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtentions.RemoveWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>Удаление из словаря элементов, удовлетворяющих предикату</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="selector">Метод отбора элементов</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Массив удалённых пар ключ-значение</returns>
        </member>
        <member name="T:System.Collections.Generic.IListExtentions">
            <summary>Методы расширения для интерфейса списка</summary>
        </member>
        <member name="M:System.Collections.Generic.IListExtentions.Initialize``1(System.Collections.Generic.IList{``0},System.Int32,System.Func{System.Int32,``0},System.Boolean)">
            <summary>Метод расширения для инициализации списка</summary>
            <param name="list">Инициализируемый объект</param>
            <param name="Count">Требуемое число элементов</param>
            <param name="Initializator">Метод инициализации</param>
            <param name="ClearBefore">Очищать предварительно (по умолчанию)</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <returns>Инициализированный список</returns>
        </member>
        <member name="M:System.Collections.Generic.IListExtentions.Mix``1(System.Collections.Generic.IList{``0})">
            <summary>Перемешать список</summary>
            <param name="list">Перемешиваемый список</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <returns>Перемешанный исходный список</returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.GetEnumerator">
            <summary>
            Возвращает перечислитель, выполняющий перебор элементов в коллекции.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Возвращает перечислитель, который осуществляет перебор элементов коллекции.
            </summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Clear">
            <summary>
            Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения. </exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="arrayIndex">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="arrayIndex"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="arrayIndex"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="T"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Count">
            <summary>
            Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.IsReadOnly">
            <summary>
            Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.
            </summary>
            <returns>
            Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.ContainsKey(`0)">
            <summary>
            Определяет, содержится ли элемент с указанным ключом в <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Значение true, если в <see cref="T:System.Collections.Generic.IDictionary`2"/> содержится элемент с данным ключом; в противном случае — значение false.
            </returns>
            <param name="key">Ключ, который требуется найти в <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Add(`0,`1)">
            <summary>
            Добавляет элемент с указанными ключом и значением в <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">Объект, используемый в качестве ключа добавляемого элемента.</param><param name="value">Объект, используемый в качестве значения добавляемого элемента.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.ArgumentException">Элемент с таким ключом уже существует в <see cref="T:System.Collections.Generic.IDictionary`2"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Remove(`0)">
            <summary>
            Удаляет элемент с указанным ключом из <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Значение true, если элемент успешно удален, в противном случае — значение false.  Этот метод также возвращает значение false, если параметр <paramref name="key"/> не найден в исходном объекте <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">Ключ элемента, который необходимо удалить.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.TryGetValue(`0,`1@)">
            <summary>
            Получает значение, связанное с указанным ключом.
            </summary>
            <returns>
            Значение true, если объект, реализующий <see cref="T:System.Collections.Generic.IDictionary`2"/>, содержит элемент с указанным ключом, в противном случае — значение false.
            </returns>
            <param name="key">Ключ, значение которого необходимо получить.</param><param name="value">Этот метод возвращает значение, связанное с указанным ключом, если он найден; в противном случае — значение по умолчанию для данного типа параметра <paramref name="value"/>. Этот параметр передается неинициализированным.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Item(`0)">
            <summary>
            Получает или задает элемент с указанным ключом.
            </summary>
            <returns>
            Элемент с указанным ключом.
            </returns>
            <param name="key">Ключ элемента, который требуется получить или задать.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">Свойство получено и параметр <paramref name="key"/> не найден.</exception><exception cref="T:System.NotSupportedException">Свойство задано, и объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Keys">
            <summary>
            Получает интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий ключи <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий ключи объекта, который реализует <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Values">
            <summary>
            Получает интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий значения <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий значения объекта, который реализует <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="M:System.Collections.BitArrayExtentions.IsPartyCorrect(System.Collections.BitArray,System.Boolean)">
            <summary>Проверка корректности чётности</summary>
            <param name="bits">Битовый массив</param>
            <param name="PartyBit">Бит чётности</param>
            <returns>Истина, если сумма бит по модулю 2 и бита чётности равна 0</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtentions.GetBitSummMod2(System.Collections.BitArray)">
            <summary>Сумма бит по модулю 2</summary>
            <param name="bits">Битовый массив</param>
            <returns>Результат сложения бит массива по модулю 2</returns>
        </member>
        <member name="M:System.EnumExtentions.GetValueAttribute``1(System.Enum)">
            <exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded. </exception>
            <exception cref="T:System.InvalidOperationException">This member belongs to a type that is loaded into the reflection-only context. See How to: Load Assemblies into the Reflection-Only Context.</exception>
        </member>
        <member name="M:System.EnumExtentions.GetValueDescription(System.Enum)">
            <exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded. </exception>
        </member>
        <member name="T:System.EventHandlerTyped1Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.Start``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.StartAsync``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.FastStart``2(System.EventHandler{``0,``1},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.FastStart``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.EventHandlerTyped2Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.Start``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.StartAsync``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.FastStart``3(System.EventHandler{``0,``1,``2},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.FastStart``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.EventHandlerTyped3Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.Start``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.StartAsync``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.FastStart``4(System.EventHandler{``0,``1,``2,``3},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.FastStart``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.IComparableExtentions">
            <summary>Класс методов-расширений для сравнимых объектов</summary>
        </member>
        <member name="M:System.IComparableExtentions.Search``1(``0[],System.Int32,System.Int32,``0)">
            <summary>Метод поиска элемента в упорядоченной коллекции половинным делением</summary>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <param name="Collection">Массив элементов, упорядоченный по возростанию</param>
            <param name="From">Начальный индекс поиска</param>
            <param name="To">КОнечный индекс поиска</param>
            <param name="Item">Искомый элемент</param>
            <returns>Индекс элемента в массиве</returns>
        </member>
        <member name="T:System.INotifyPropertyChangedExtentions">
            <summary>Класс методов-расширений интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String)">
            <summary>Подписка на событие изменения указанного свйоства</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Name">Имя свйоства</param>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String)">
            <summary>Подписка на событие изменения указанного свйоства</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Name">Имя свйоства</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String[])">
            <summary>Подписка на событие изменения указанных свйоств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свйоств</param>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String[])">
            <summary>Подписка на событие изменения указанных свйоств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свйоств</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Подписка на событие изменения указанных свйоств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свйоств</param>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Подписка на событие изменения указанных свйоств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свйоств</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="T:System.INotifyPropertyChangedExtentions.DependentPropertyChangedEventArgs">
            <summary>Аргумент события изменения зависимого свойства</summary>
        </member>
        <member name="P:System.INotifyPropertyChangedExtentions.DependentPropertyChangedEventArgs.FromProperties">
            <summary>Перечень свойств, породивших изменение</summary>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.DependentPropertyChangedEventArgs.#ctor(System.String,System.String[])">
            <summary>Инициализация нового аргумента события изменения зависимого свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
            <param name="FromProperties">Список свойств, породивших изменение</param>
        </member>
        <member name="F:System.INotifyPropertyChangedExtentions.sf_ObjectsSet">
            <summary>Перечень слабых ссылок на отслеживаемые объекты</summary>
        </member>
        <member name="F:System.INotifyPropertyChangedExtentions.sf_RegistrationPool">
            <summary>Словарь описаний связей между свойствами типов</summary>
        </member>
        <member name="T:System.INotifyPropertyChangedExtentions.RegistratorInfo">
            <summary>Информация о связях между свойствами типов</summary>
        </member>
        <member name="F:System.INotifyPropertyChangedExtentions.RegistratorInfo.f_Dependences">
            <summary>Словарь связей имён свойств типа</summary>
        </member>
        <member name="F:System.INotifyPropertyChangedExtentions.RegistratorInfo.f_Handler">
            <summary>Обработчик события изменения свойства объекта</summary>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.RegistratorInfo.#ctor(System.Collections.Generic.Dictionary{System.String,System.String[]})">
            <summary>Инициализация нового экземпляра информации и связях между свойствами типа</summary>
            <param name="Dependences">Словарь имён свойст зависимостей</param>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.RegistratorInfo.Subscribe(System.ComponentModel.INotifyPropertyChanged,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>Метод установки обработчика событий обновления свойства объекта, генерирующего вторичные события обновления зависимых свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> в объекте <paramref name="obj"/></param>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.RegistratorInfo.UnSubscrige(System.ComponentModel.INotifyPropertyChanged)">
            <summary>Отписка от события обновления свойств объекта</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.OnGarbageCollected(System.Object,System.EventArgs)">
            <summary>Обработка событий слорки мусора в системе</summary>
            <param name="Sender">Источник события - не используется</param>
            <param name="e">Аргумент события - не используется</param>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.PropertyDependences_Register``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>
            Создание связей между свойствами объекта на основе атрибутов <see cref="T:System.AffectsTheAttribute"/> и <see cref="T:System.DependenceOnAttribute"/>
            </summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события обновления свойства</param>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.PropertyDependences_Register_Disposable``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>
            Создание связей между свойствами объекта на основе атрибутов <see cref="T:System.AffectsTheAttribute"/> и <see cref="T:System.DependenceOnAttribute"/>
            </summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события обновления свойства</param>
            <typeparam name="T">Тип объекта</typeparam>
            <returns></returns>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.PropertyDependences_Unregister``1(``0)">
            <summary>
            Разрушение связей между свойствами, созданными методом <see cref="M:System.INotifyPropertyChangedExtentions.PropertyDependences_Register``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})"/>
            </summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:System.INotifyPropertyChangedExtentions.GetRegistrator(System.Type)">
            <summary>Метод получения информации о связях между свойствами объекта класса</summary>
            <param name="type">Тип рассматриваемого объекта</param>
            <returns>Информация о связях между свойствами объекта</returns>
        </member>
        <member name="M:System.IO.StreamExtentions.GetBufferedStream(System.IO.Stream,System.Int32)">
            <summary>
            Создать буферизованный поток данных
            </summary>
            <param name="DataStream">Исходный поток данных</param>
            <param name="BufferSize">Размер буфера (по умолчанию 4096 байта)</param>
            <returns>Буферизованный поток данных</returns>
        </member>
        <member name="M:System.IO.BinaryReaderExtentions.IsEOF(System.IO.BinaryReader)">
            <summary>
            Признак конца потока
            </summary>
            <param name="reader">Объект чтения потока</param>
            <returns>Истина, если поток закончен</returns>
        </member>
        <member name="M:System.IO.BinaryReaderExtentions.GetByteBuffer(System.IO.BinaryReader,System.Int32)">
            <summary>
            Получить перечисление, содержащее массивы байт заданной длины из потока 
            </summary>
            <param name="reader">Объект чтения потока данных</param>
            <param name="BufferSize">Размер буфера</param>
            <returns>Перечислитель</returns>
        </member>
        <member name="T:System.IO.DirectoryInfoExtentions">
            <summary>Класс методов-расширений для объектов класса System.IO.DirectoryInfo</summary>
        </member>
        <member name="M:System.IO.DirectoryInfoExtentions.GetFilesCount(System.IO.DirectoryInfo)">
            <summary>Определить число всех вложенных файлов</summary>
            <param name="Directory">Исследуемая дирректория</param>
            <returns>Число файлов во всех вложенных поддиректориях</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtentions.GetSize(System.IO.DirectoryInfo)">
            <summary>Определить объём всех вложенных файлов включая поддиректории</summary>
            <param name="Directory">Исследуемая дирректория</param>
            <returns>Число байт всех вложенных файлов</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtentions.GetSubdirectoriesCount(System.IO.DirectoryInfo)">
            <summary>Определить число поддерикторий</summary>
            <param name="Directory">Исследуемая дирректория</param>
            <returns>Число элементов в дереве поддерикторий</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtentions.IsEmpty(System.IO.DirectoryInfo)">
            <summary>Проверить - является ли дирректория пустой</summary>
            <param name="Directory">Проверяемая дирректория</param>
            <returns>Истина, если дирректория пуста</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtentions.GetWacher(System.IO.DirectoryInfo,System.String)">
            <summary>Получить объект наблюдения за дирректорией</summary>
            <param name="directory">Наблюдаемая дирректория</param>
            <param name="filter">Фильтр файлов</param>
            <returns>Объект наблюдатель</returns>
        </member>
        <member name="T:System.IO.FileInfoExtentions">
            <summary>Класс методов расширений для объектов класса System.IO.FileInfo</summary>
        </member>
        <member name="M:System.IO.FileInfoExtentions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo)">
            <summary>Скопировать файл в дирректорию</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationDirectory">Дирректория назначения</param>
            <returns>Файл копия</returns>
        </member>
        <member name="M:System.IO.FileInfoExtentions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo,System.Boolean)">
            <summary>Скопировать файл в дирректорию</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationDirectory">Дирректория назначения</param>
            <param name="Owerride">Перезаписать в случае наличия файла</param>
            <returns>Файл копия</returns>
        </member>
        <member name="M:System.IO.FileInfoExtentions.CopyTo(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>Скопировать файл</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationFile">Файл копия</param>
        </member>
        <member name="M:System.IO.FileInfoExtentions.CopyTo(System.IO.FileInfo,System.IO.FileInfo,System.Boolean)">
            <summary>Скопировать файл</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationFile">Файл копия</param>
            <param name="Owerride">Перезаписать в случае наличия файла</param>
        </member>
        <member name="M:System.IO.FileInfoExtentions.GetFileNameWithoutExtension(System.IO.FileInfo)">
            <summary>Получить имя файла без расширения</summary>
            <param name="file">Файл</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtentions.GetFullFileNameWithoutExtension(System.IO.FileInfo)">
            <summary>Получить имя файла без расширения</summary>
            <param name="file">Файл</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtentions.GetFullFileNameWithNewExtension(System.IO.FileInfo,System.String)">
            <summary>Получить имя файла c новым расширением</summary>
            <param name="file">Файл</param>
            <param name="NewExt">Новое расширение файла в формате ".exe"</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtentions.WriteAllBytes(System.IO.FileInfo,System.Byte[],System.Boolean)">
            <summary>Записать массив байт в файл</summary>
            <param name="file">Файл данных</param>
            <param name="Data">Данные</param>
            <param name="Append">Если истина, то данные будут добавлены в конец файла</param>
        </member>
        <member name="M:System.IO.FileInfoExtentions.WriteAllBytes(System.IO.FileInfo,System.IO.Stream,System.Int32,System.Boolean,System.Func{System.Int64,System.Byte[],System.Boolean},System.EventHandler{System.EventArgs{System.IO.FileInfo,System.IO.Stream}})">
            <summary>Записать все данные из потока в файл</summary>
            <param name="file">Файл данных</param>
            <param name="DataStream">Поток - источник данных</param>
            <param name="BufferSize">Размер буфера чтения по умолчанию 1024 байта</param>
            <param name="Append">Флаг добавления данных в конец файла</param>
            <param name="CompliteHandler">
            Обработчик текущего положения коретки чтения данных из потока. 
            Вызывается после чтения данных в буфер и до помещения их в файл.
            Должен вернуть истину, что бы данные были переданы в файл и процесс был продолжен.
            </param>
            <param name="OnComplite">Обработчик события завершения процесса записи данных</param>
        </member>
        <member name="M:System.IO.FileInfoExtentions.GetWatcher(System.IO.FileInfo)">
            <summary>Получить объект наблюдения за файлом</summary>
            <param name="file">Наблюдаемый файл</param>
            <returns>Объект наблюдатель</returns>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializerExtentions">
            <summary>Класс методов-расширений для XML-сериализаторов</summary>
        </member>
        <member name="F:System.Xml.Serialization.XmlSerializerExtentions.sf_LockObject">
            <summary>Объект межпоточной блокировки доступа</summary>
        </member>
        <member name="F:System.Xml.Serialization.XmlSerializerExtentions.sf_XmlSerializersPool">
            <summary>Словарь типов - сериализаторов</summary>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerExtentions.GetSerializer(System.Type)">
            <summary>Получить XML-сериализатор по указанному типу</summary>
            <param name="type">Тип XML-сериализатора</param>
            <returns>XML-сериализатор</returns>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerExtentions.GetSerializer``1">
            <summary>Получить XML-сериализатор по указанному типу</summary>
            <param name="type">Тип XML-сериализатора</param>
            <returns>XML-сериализатор</returns>
        </member>
        <member name="M:System.Xml.XPath.ChildQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get the child value</exception>
        </member>
        <member name="M:System.Xml.XPath.DescendantQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get the decendent nodes value</exception>
        </member>
        <member name="M:System.Xml.XPath.FilterQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get value</exception>
        </member>
        <member name="M:System.Xml.XPath.QueryBuilder.ProcessAxis(System.Xml.XPath.Axis,System.Xml.XPath.Query)">
            
        </member>
        <member name="T:System.Xml.XPath.XmlCaseOrder">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.None">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.UpperFirst">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.LowerFirst">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XmlCharType">
            <internalonly />
            <devdoc>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XmlDataType">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlDataType.Text">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlDataType.Number">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathCollection.MatchesAny(System.Collections.ArrayList,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:System.Xml.XPath.XPathParser.ParseXPathExpresion(System.String)">
            <exception cref="T:System.Xml.XPath.XPathException"><see cref="P:System.Xml.XPath.XPathScanner.SourceText"/>  has an invalid token</exception>
        </member>
        <member name="M:System.Xml.XPath.XPathParser.ParseXPathPattern(System.String)">
            <exception cref="T:System.Xml.XPath.XPathException"><see cref="P:System.Xml.XPath.XPathScanner.SourceText"/>  has an invalid token</exception>
        </member>
        <member name="P:System.Xml.XPath.XPathQuery.GetXPathQueries">
            use can store this compiled expression to query other documents
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NodeType">
            <devdoc>
                <para>
                    Gets the type of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Name">
            <devdoc>
                <para>
                    Gets the name of
                    the current node, including the namespace prefix.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.LocalName">
            <devdoc>
                <para>
                    Gets the name of the current node without the namespace prefix.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NamespaceURI">
            <devdoc>
                <para>
                    Gets the namespace URN (as defined in the W3C Namespace Specification) of the current namespace scope.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Prefix">
            <devdoc>
                <para>
                    Gets the namespace prefix associated with the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.HasValue">
            <devdoc>
                <para>
                    Gets a value indicating whether
                    <see cref='P:System.Xml.XPath.XPathReader.Value' /> has a value to return.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Value">
            <devdoc>
                <para>
                    Gets the text value of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Depth">
            <devdoc>
                <para>
                    Gets the depth of the
                    current node in the XML element stack.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.BaseURI">
            <devdoc>
                <para>
                    Gets the base URI of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.IsEmptyElement">
            <devdoc>
                <para>
                    Gets a value indicating whether
                    the current
                    node is an empty element (for example, &lt;MyElement/&gt;).
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.IsDefault">
            <devdoc>
                <para>
                    Gets a value indicating whether the current node is an
                    attribute that was generated from the default value defined
                    in the DTD or schema.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.QuoteChar">
            <devdoc>
                <para>
                    Gets the quotation mark character used to enclose the value of an attribute
                    node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.XmlSpace">
            <devdoc>
                <para>Gets the current xml:space scope.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.XmlLang">
            <devdoc>
                <para>Gets the current xml:lang scope.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.AttributeCount">
            <devdoc>
                <para> The number of attributes on the current node.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.Int32)">
            <devdoc>
                <para>Gets the value of the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the specified
                    <see cref='P:System.Xml.XPath.XPathReader.Name' /> .
                </para>
            </devdoc>
            <exception cref="T:System.InvalidOperationException">
                An <see cref="T:System.Xml.XmlReader" /> method was called before a
                previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" /> is thrown
                with the message “An asynchronous operation is already in progress.”
            </exception>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.String,System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the
                    specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' /> and
                    <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.EOF">
            <devdoc>
                <para>
                    Gets
                    a value indicating whether XmlReader is positioned at the end of the
                    stream.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.ReadState">
            <devdoc>
                <para>
                    Returns
                    the read state of the stream.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NameTable">
            <devdoc>
                <para>
                    Gets the XmlNameTable associated with this
                    implementation.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.Xml.XmlReader,System.Xml.XPath.XPathCollection)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.String,System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.IO.TextReader,System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.String,System.Xml.XPath.XPathCollection)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.Int32)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.Xml.XPath.XPathQuery)">
            <internalonly />
            <devdoc>
                <para>return true when the </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MatchesAny(System.Collections.ArrayList)">
            <internalonly />
            <devdoc>
                <para> return true if one of the queries matches with the XmlReader context. </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadUntilMatch">
            <internalonly />
            <devdoc>
                <para> return true if one of the queries matches with the XmlReader context. </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Read">
            <devdoc>
                <para>
                    Reads the next
                    node from the stream.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.String)">
            <devdoc>
                <para>Moves to the attribute with the specified <see cref='P:System.Xml.XPath.XPathReader.Name' /> .</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.String,System.String)">
            <devdoc>
                <para>
                    Moves to the attribute with the specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' />
                    and <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.Int32)">
            <devdoc>
                <para>Moves to the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToFirstAttribute">
            <devdoc>
                <para>
                    Moves to the first attribute.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToNextAttribute">
            <devdoc>
                <para>
                    Moves to the next attribute.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToElement">
            <devdoc>
                <para>
                    Moves to the element that contains the current attribute node.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the specified
                    <see cref='P:System.Xml.XPath.XPathReader.Name' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.String,System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the
                    specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' /> and
                    <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.Int32)">
            <devdoc>
                <para>Gets the value of the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Close">
            <devdoc>
                <para>
                    Closes the stream, changes the <see cref='P:System.Xml.XPath.XPathReader.ReadState' />
                    to Closed, and sets all the properties back to zero.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadString">
            <devdoc>
                <para>Reads the contents of an element as a string.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.LookupNamespace(System.String)">
            <devdoc>
                <para>
                    Resolves a namespace prefix in the current element's scope.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ResolveEntity">
            <devdoc>
                <para>Resolves the entity reference for nodes of NodeType EntityReference.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadAttributeValue">
            <devdoc>
                <para>
                    Parses the attribute value into one or more Text and/or EntityReference node
                    types.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadInnerXml">
            <devdoc>
                <para>Reads all the content (including markup) as a string.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadOuterXml">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XPathReaderException">
            <devdoc>
                <para>
                    Represents the exception that is thrown when there is error processing an
                    XPath expression.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.RegExExtentions.OrDefault(System.Text.RegularExpressions.Match,System.String)">
            <summary>Метод получения значения из результатов совпадения поиска</summary>
            <param name="match">Результат совпадения поиска</param>
            <param name="DefaultString">Значение по умолчанию</param>
            <returns>Результат поска, либо значение по умолчанию</returns>
        </member>
        <member name="T:System.LamdaDisposable">
            <summary>Объект, выполняющий указанное действие при сборке мусора</summary>
        </member>
        <member name="M:System.LamdaDisposable.#ctor(System.Action)">
            <summary>Инициализация нового уничтожаемого объекта с указанием действия при уничтожении</summary>
            <param name="DisposableAction">Дейтсвие, выполняемое при уничтожении объекта</param>
        </member>
        <member name="M:System.LamdaDisposable.Dispose">
            <summary>Метод уничтожения объекта, вызывающий указанное действие</summary>
        </member>
        <member name="T:System.NotImplementedAttribute">
            <summary>Атрибут признака нереализованности</summary>
        </member>
        <member name="P:System.NotImplementedAttribute.Message">
            <summary>Сообщение</summary>
        </member>
        <member name="M:System.NotImplementedAttribute.#ctor">
            <summary>Новый атрибут нереализованности</summary>
        </member>
        <member name="M:System.NotImplementedAttribute.#ctor(System.String)">
            <summary>Новый атрибут нереализованности</summary>
            <param name="Message">Сообщение (почему не раелизовано?)</param>
        </member>
        <member name="M:System.NotImplementedAttribute.IsDefaultAttribute">
            <summary>Признак атрибута "по умолчанию"</summary>
            <returns>Истина, если указан незаполненный атрибут</returns>
        </member>
        <member name="T:System.EventHandlerArgs`2">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandlerArgs`3">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TResult">Тип результата события</typeparam>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
            <returns>Результат события</returns>
        </member>
        <member name="T:System.EventHandler`2">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TEventParameter">Тип параметра аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`3">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TEventParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TEventParameter2">Тип параметра 2 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`4">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TEventParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TEventParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TEventParameter3">Тип параметра 3 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.ExceptionEventHandler`1">
            <summary>Обработчик событий генерации исключения</summary>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргументы события</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="T:System.ExceptionEventHandlerExtentions">
            <summary>Класс методов расширений для обработчика событий генерации исключений</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerExtentions.Start``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0})">
            <summary>Генерация события обработки исключения</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtentions.StartAsync``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0},System.AsyncCallback,System.Object)">
            <summary>Асинхронная генерация события обработки исключения</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <param name="CallBack">Делегат заврешения вызова события</param>
            <param name="State">ОБъект состояния, передаваемый в обработчик завершающего метода</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtentions.FastStart``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0})">
            <summary>Быстрый запуск события без учёта многопоточных компонентов</summary>
            <param name="Handler">Обработчики события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <typeparam name="TException">Тип события</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtentions.ThrowIfUnhandled``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0},System.Nullable{System.Boolean})">
            <summary>
            Вызвать <typeparamref name="TException">исключение</typeparamref>, 
            если обработчики его не обработали, либо если кто-либо из обработчиков принял решение вызвать исключение
            </summary>
            <param name="Handler">Обработчики событий</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <param name="IsHandledDefault">
            Если истина, то исключение считается обработанным до тех пор, пока обработчик обытия не укажет обратного
            Если ложь, то обработчики должны явно указать, что исключение обработано.
            По умолчанию значение не определено (= null) - при наличии обработчиков у события исключение считается обработанным. Иначе оно генерируется. 
            </param>
            <typeparam name="TException">Тип исключения</typeparam>
            <exception cref="T:System.Exception"><typeparamref name="TException">Исключение</typeparamref> генерируется при отсутствии обработки его обработчиками события</exception>
        </member>
        <member name="T:System.ExceptionEventHandlerArgs`1">
            <summary>Аргументы события исключения</summary>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="F:System.ExceptionEventHandlerArgs`1.f_Unhandled">
            <summary>Флаг необходимости генерации исключения</summary>
        </member>
        <member name="F:System.ExceptionEventHandlerArgs`1.f_IsHandled">
            <summary>Флаг признака обработки исключения обработчиками</summary>
        </member>
        <member name="P:System.ExceptionEventHandlerArgs`1.IsHandled">
            <summary>Исключение обработано</summary>
        </member>
        <member name="P:System.ExceptionEventHandlerArgs`1.NeedToThrow">
            <summary>Признак необходимости генерации исключения</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.#ctor(`0)">
            <summary>Новый аргумент события генерации исключения</summary>
            <param name="Error">Исключение</param>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.Handled">
            <summary>Исключение обработано</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.Unhandled">
            <summary>Исключение должно быть сгенерировано в любом случае</summary>
        </member>
        <member name="T:System.DecimalExtentions">
            <summary>Расширения для чисел двойной точности</summary>
        </member>
        <member name="M:System.DecimalExtentions.IsInt(System.Decimal)">
            <summary>Является ли число целым?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число целое</returns>
        </member>
        <member name="M:System.DecimalExtentions.GetInverse(System.Decimal)">
            <summary>Получить обратное число</summary>
            <param name="x">Инвертируемое число</param>
            <returns>Число, обратное к исходном</returns>
        </member>
        <member name="M:System.LambdaProcessor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="T:System.Processor">
            <summary>Класс объектов, выполняющих некоторое циклическое действие в отдельном фоновом потоке</summary>
        </member>
        <member name="F:System.Processor.sf_AcyncException">
            <summary>Объект-ислюкение, передаваемое в качестве параметра события ошибки при рассинхронизации потока процессора</summary>
        </member>
        <member name="P:System.Processor.Now">
            <summary>Текущее время системы</summary>
        </member>
        <member name="E:System.Processor.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
            <summary>Событие изменения свойства объекта</summary>
        </member>
        <member name="M:System.Processor.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Вызов события изменения свойства объекта</summary>
             <param name="e">Параметры события изменения свойства объекта, содержашие имя свойства</param>
        </member>
        <member name="M:System.Processor.OnPropertyChanged(System.String)">
            <summary>Вызов собйтия изменения свойтсва объекта с указанием имени свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="E:System.Processor.EnableChanged">
            <summary>Событие изменения свойства активности процессора</summary>
        </member>
        <member name="M:System.Processor.OnEnableChanged(System.EventArgs)">
            <summary>Источник собйтия изменения свойства активности процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.ProcessStarted">
            <summary>Событие запуска процессора</summary>
        </member>
        <member name="M:System.Processor.OnProcessStarted(System.EventArgs)">
            <summary>Источник события запуска процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.ProcessComplited">
            <summary>Событие завершения работы процессора</summary>
        </member>
        <member name="M:System.Processor.OnProcessComplited(System.EventArgs)">
            <summary>Источник события завершения работы процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.Error">
            <summary>Событие, вознакающие при возникновении исключений в процессе работы процессора</summary>
        </member>
        <member name="M:System.Processor.OnError(System.ExceptionEventHandlerArgs{System.Exception})">
            <summary>Источник события возникновения исключительной ситуации в процессе работы процессора</summary>
            <param name="e">Аргумент события ошибки, содержащий объект исключения</param>
        </member>
        <member name="F:System.Processor.f_JoinThreadTimeout">
            <summary>
            Таймаут времени ожидания синхронизации потока обработки при его завершении, 
            после которого поток прерывается методом Abort()
            По умолчанию 100 мс.
            </summary>
        </member>
        <member name="F:System.Processor.f_Enabled">
            <summary>Флаг активности потока обработки. Пока значение флага "истина" - поток выполняется</summary>
        </member>
        <member name="F:System.Processor.f_StartStopSectionLocker">
            <summary>Объект синхронизации запуска/остановки процессора - только для чтения</summary>
        </member>
        <member name="F:System.Processor.f_MainWorkThread">
            <summary>Основной поток работы процессора</summary>
        </member>
        <member name="F:System.Processor.f_StartTime">
            <summary>Время запуска</summary>
        </member>
        <member name="F:System.Processor.f_StopTime">
            <summary>Время остановки</summary>
        </member>
        <member name="F:System.Processor.f_Monitor">
            <summary>Объект-наблюдатель за состоянием процессора</summary>
        </member>
        <member name="F:System.Processor.f_Priority">
            <summary>Базовый приоритет потока процессора</summary>
        </member>
        <member name="F:System.Processor.f_ActionTimeout">
            <summary>Таймаут выполнения между циклами процессора </summary>
        </member>
        <member name="F:System.Processor.f_Set_Timeout">
            <summary>Метод установки времени таймаута для работающего потока процессора</summary>
        </member>
        <member name="F:System.Processor.f_IsSychronus">
            <summary>Признак синхронной работы</summary>
        </member>
        <member name="F:System.Processor.f_ErrorIfAcync">
            <summary>Флаг, разрешающий вызов события ошибки в случае рассинхронизации потока</summary>
        </member>
        <member name="F:System.Processor.f_CyclesCount">
            <summary>Количество выполненных циклов обработки</summary>
        </member>
        <member name="F:System.Processor.f_NameForeNewMainThread">
            <summary>Имя для генерируемой потока выполнения процессора</summary>
        </member>
        <member name="F:System.Processor.f_Get_LastDeltaTime">
            <summary>Метод извлечения времени выполнения одного цикла основного метода процессора</summary>
        </member>
        <member name="F:System.Processor.f_StartWaitHandle">
            <summary>Объект синхрониации потоков по запуску процессора</summary>
        </member>
        <member name="F:System.Processor.f_StopWaitHandle">
            <summary>Объект синхрониации потоков по остановке процессора</summary>
        </member>
        <member name="P:System.Processor.Priority">
            <summary>Приоритет выполнения метода наблюдения</summary>
        </member>
        <member name="P:System.Processor.Enable">
            <summary>Признак активности процессора</summary>
        </member>
        <member name="P:System.Processor.MainThread">
            <summary>Основной поток работы процессора</summary>
        </member>
        <member name="P:System.Processor.JoinThreadTimeout">
            <summary>ТАймаут времени синхронизации основного потока процессора с потоком, завершившим его работу.</summary>
        </member>
        <member name="P:System.Processor.StartTime">
            <summary>Время запуска</summary>
        </member>
        <member name="P:System.Processor.StopTime">
            <summary>Время остановки</summary>
        </member>
        <member name="P:System.Processor.ElapsedTime">
            <summary>Время, прошедшее после запуска</summary>
        </member>
        <member name="P:System.Processor.Monitor">
            <summary>ОБъект-наблюдатель за состоянием процессора</summary>
        </member>
        <member name="P:System.Processor.ActionTimeout">
            <summary>ТАймаут основной циклической операции в миллисекундах</summary>
        </member>
        <member name="P:System.Processor.IsSynchronus">
            <summary>Признак синхронной работы</summary>
        </member>
        <member name="P:System.Processor.ErrorIfAsync">
            <summary>ГЕнерировать ошибку в случае рассинхронизации?</summary>
        </member>
        <member name="P:System.Processor.CyclesCount">
            <summary>Количество пройденных циклов</summary>
        </member>
        <member name="M:System.Processor.Start">
            <summary>Запуск обработки</summary>
        </member>
        <member name="M:System.Processor.Stop">
            <summary>Остановка обработки</summary>
        </member>
        <member name="M:System.Processor.WaitToStart(System.Nullable{System.TimeSpan})">
            <summary>Блокировать поток до запуска процессора</summary>
        </member>
        <member name="M:System.Processor.WaitToStop(System.Nullable{System.TimeSpan})">
            <summary>Блокировать пото до остановки процессора</summary>
        </member>
        <member name="M:System.Processor.ThreadMethod">
            <summary>Основной метод процессора, выполняемый в отдельном потоке </summary>
        </member>
        <member name="M:System.Processor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="M:System.Processor.InitializeAction">
            <summary>Инициализация процесса</summary>
        </member>
        <member name="M:System.Processor.Initializer">
            <summary>
            Метод инициализации. Вызывается после запуска обработки перед началом основного цикла.
            По умолчанию вызывает генерацию события запуска процессора
            </summary>
        </member>
        <member name="M:System.Processor.Finalizer">
            <summary>
            Метод, завершающий процесс обработки. Вызывается после выхода процессора из основного цикла.
            По умолчанию вызывает генерацию события завершения работы процессора
            </summary>
        </member>
        <member name="M:System.Processor.FinalizeAction">
            <summary>Завершающее действие процесса</summary>
        </member>
        <member name="M:System.Processor.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:System.StreamingObjectReader`1">
            <summary>Класс поточного чтения объектов из потока данных</summary>
            <typeparam name="T">Тип читаемых объектов</typeparam>
        </member>
        <member name="E:System.StreamingObjectReader`1.Readed">
            <summary>Событие чтения нового объекта из потока данных</summary>
        </member>
        <member name="M:System.StreamingObjectReader`1.OnReaded(System.EventArgs{`0})">
            <summary>Источник события чтения объекта из потока данных</summary>
            <param name="e">Аргумент события, содержащий прочитанный объект</param>
        </member>
        <member name="M:System.StreamingObjectReader`1.OnReaded(`0)">
            <summary>Источник события чтения объекта из потока данных</summary>
            <param name="obj">Прочитанный объект</param>
        </member>
        <member name="F:System.StreamingObjectReader`1.f_DataStream">
            <summary>Потока данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.DataStream">
            <summary>Потока данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.Complited">
            <summary>Процент готовности</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.Speed">
            <summary>Скорость обработки данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.RemainingTime">
            <summary>Оставшееся время до окончания обработки</summary>
        </member>
        <member name="T:System.StringExtentions">
            <summary>Методы-расширения класса <see cref="T:System.String">строк</see></summary>
        </member>
        <member name="M:System.StringExtentions.GetBracketText(System.String,System.Int32@,System.String,System.String)">
            <summary>
            Выделение подстроки, ограниченной шаблоном начала и шаблоном окончания строки начиная с указанного смещения
            </summary>
            <param name="Str">Входная строка</param>
            <param name="Offset">
            Смещеине во входной строке начала поиска - в конце работы метода соответствует месту окончания поиска
            </param>
            <param name="Open">Шаблон начала подстроки</param>
            <param name="Close">Шаблон окончания подстроки</param>
            <returns>Подстрока, заключённая между указанными шаблонами начала и окончания</returns>
            <exception cref="T:System.FormatException">
            Если шаблон завершения строки на нейден, либо если количество шаблонов начала строки превышает 
            количество шаблонов окончания во входной строке
            </exception>
        </member>
        <member name="M:System.StringExtentions.IsNullOrEmpty(System.String)">
            <summary>Проверка строки на пустоту, либо нулевую ссылку</summary>
            <param name="Str">Проверяемая строка</param>
            <returns>Истина, если трока пуста, либо если передана нулевая ссылка</returns>
        </member>
        <member name="M:System.StringExtentions.ClerSymbolsAtBegin(System.String,System.Char[])">
            <summary>Удаление символов в начале строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в начале</returns>
        </member>
        <member name="M:System.StringExtentions.ClerSymbolsAtEnd(System.String,System.Char[])">
            <summary>Удаление символов в конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в конце</returns>
        </member>
        <member name="M:System.StringExtentions.ClearSymbolsAtBeginAndEnd(System.String,System.Char[])">
            <summary>Удаление символов в начале и конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в начале и конце</returns>
        </member>
        <member name="M:System.StringExtentions.ClearSystemSymbolsAtBeginAndEnd(System.String)">
            <summary>Удаление служебных символов в начале и конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <returns>Новая строка с удалёнными служебными символами в началеи конце</returns>
        </member>
        <member name="T:System.IInitializable">
            <summary>Объект, поддерживающий инициализацию</summary>
        </member>
        <member name="M:System.IInitializable.Initialize">
            <summary>Инициализация</summary>
        </member>
        <member name="T:System.IInitializable`1">
            <summary>Объект, поддерживающий инициализацию с параметром</summary>
            <typeparam name="T">Тип параметра инициализации</typeparam>
        </member>
        <member name="M:System.IInitializable`1.Initialize(`0)">
            <summary>Инициализация</summary>
            <param name="t">Параметр</param>
        </member>
        <member name="T:System.IInitializable`2">
            <summary>Объект, поддерживающий инициализацию с двумя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`2.Initialize(`0,`1)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
        </member>
        <member name="T:System.IInitializable`3">
            <summary>Объект, поддерживаюий инициализацию с тремя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`3.Initialize(`0,`1,`2)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
        </member>
        <member name="T:System.IInitializable`4">
            <summary>ОБъект, поддерживающий инициализацию с четырьмя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
            <typeparam name="T4">Тип четвёртого патаметра</typeparam>
        </member>
        <member name="M:System.IInitializable`4.Initialize(`0,`1,`2,`3)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
            <param name="t4">Четвёртый параметр</param>
        </member>
        <member name="T:System.IInitializable`5">
            <summary>ОБъект, поддерживающий инициализацию с пятью параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
            <typeparam name="T4">Тип четвёртого патаметра</typeparam>
            <typeparam name="T5">Тип пятого патаметра</typeparam>
        </member>
        <member name="M:System.IInitializable`5.Initialize(`0,`1,`2,`3,`4)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
            <param name="t4">Четвёртый параметр</param>
            <param name="t5">Пятый параметр</param>
        </member>
        <member name="T:System.Month">
            <summary>Месяцы года</summary>
        </member>
        <member name="F:System.Month.January">
            <summary>Январь</summary>
        </member>
        <member name="F:System.Month.February">
            <summary>Февраль</summary>
        </member>
        <member name="F:System.Month.March">
            <summary>Март</summary>
        </member>
        <member name="F:System.Month.April">
            <summary>Апрель</summary>
        </member>
        <member name="F:System.Month.May">
            <summary>Май</summary>
        </member>
        <member name="F:System.Month.June">
            <summary>Июнь</summary>
        </member>
        <member name="F:System.Month.July">
            <summary>Июль</summary>
        </member>
        <member name="F:System.Month.August">
            <summary>Август</summary>
        </member>
        <member name="F:System.Month.September">
            <summary>Сентябрь</summary>
        </member>
        <member name="F:System.Month.October">
            <summary>Октябрь</summary>
        </member>
        <member name="F:System.Month.November">
            <summary>Ноябрь</summary>
        </member>
        <member name="F:System.Month.December">
            <summary>Декабрь</summary>
        </member>
        <member name="T:System.EventArgs`1">
            <summary>Аргумент события с типизированным параметром</summary>
            <typeparam name="TArgument">Тип параметра аргумента</typeparam>
        </member>
        <member name="P:System.EventArgs`1.Argument">
            <summary>Параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`1.#ctor(`0)">
            <summary>Новый аргумент события с типизированным параметром</summary>
            <param name="Argument">Параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`1.ToString">
            <summary>
            Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.
            </summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:System.EventArgs`1.op_Implicit(System.EventArgs{`0})~`0">
            <summary>Оператор неявного преобразования аргумента события к типу содержащегося в нём значения </summary>
            <param name="Args">Аргумент события</param>
            <returns>Хранимый объект</returns>
        </member>
        <member name="M:System.EventArgs`1.op_Implicit(`0)~System.EventArgs{`0}">
            <summary>
            Оgератор неявного преобразования типа зранимого значения в обёртку из аргумента события, содержащего это значение
            </summary>
            <param name="Argument">Объект аргумента события</param>
            <returns>Аргумент события</returns>
        </member>
        <member name="T:System.EventArgs`2">
            <summary>Аргумент события с двумя типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип первого параметра</typeparam>
            <typeparam name="TArgument2">Тип второго параметра</typeparam>
        </member>
        <member name="P:System.EventArgs`2.Argument1">
            <summary>Первый аргумент</summary>
        </member>
        <member name="P:System.EventArgs`2.Argument2">
            <summary>Второй аргумент</summary>
        </member>
        <member name="M:System.EventArgs`2.#ctor">
            <summary>Новый аргумент события с двумя параметрами</summary>
        </member>
        <member name="M:System.EventArgs`2.#ctor(`0,`1)">
            <summary>Новый аргумент события с двумя параметрами</summary>
            <param name="Argument1">Первый аргумент события</param>
            <param name="Argument2">Второй аргумент события</param>
        </member>
        <member name="T:System.ArrayExtantions">
            <summary>Методы расширения для массивов</summary>
        </member>
        <member name="M:System.ArrayExtantions.Split``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Разделить входной массив на подмассивы указанным методом</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Разделяемый массив</param>
            <param name="Splitter">Метод, возвращающий истину, когда надо начать новый подмассив</param>
            <returns>
            Массив подмассивов элементов исходного массива, разделённый выбранными указанным методом элементами.
            Выбранные элементы в результат не входят.
            </returns>
        </member>
        <member name="M:System.ArrayExtantions.qSort``1(``0[],System.Int32,System.Int32)">
            <summary>Быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
        </member>
        <member name="M:System.ArrayExtantions.qSort_t``1(``0[],System.Int32,System.Int32)">
            <summary>Быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
        </member>
        <member name="M:System.ArrayExtantions.GetComplexHashCode``1(``0[])">
            <summary>Рассчёт хеш-суммы всех элементов массива</summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="Objects">Массив элементов</param>
            <returns>Хеш-сумма элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtantions.Concatinate``1(``0[],``0[])">
            <summary>Объединение с массивом элементов</summary>
            <param name="A">Исходный массив</param>
            <param name="B">Присоединяемый массив</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>Массив из объединёных элементов</returns>
        </member>
        <member name="M:System.ArrayExtantions.GetSelectedValue``2(``0[],System.Func{``0,``1,``1})">
            <summary>Получить элемент массива</summary>
            <param name="A">Массив элементов</param>
            <param name="Selector">Метод выбора элемента массива</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TOut">Тип выходного элемента</typeparam>
            <returns>Выбранный элемент массива</returns>
        </member>
        <member name="M:System.ArrayExtantions.ConvertTo``2(``0[],System.Converter{``0,``1})">
            <summary>Преобразовать тип элементов массива</summary>
            <param name="In">Исходный массив элементов</param>
            <param name="converter">Метод преобразования элемента массива</param>
            <typeparam name="TIn">Исходный тип элементов массива</typeparam>
            <typeparam name="TOut">Требуемый тип элементов массива</typeparam>
            <returns>Массив преобразованных элементов</returns>
        </member>
        <member name="M:System.ArrayExtantions.Foreach``1(``0[],System.Action{``0})">
            <summary>Выполнение действия для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемой действие</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtantions.Foreach``1(``0[],System.Action{``0},System.Func{System.Exception,System.Boolean})">
            <summary>Выполнение действия для всех элементов массива с обработкой исключений</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемое действие</param>
            <param name="ErrorHandler">Обработчик исключения</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtantions.Foreach``2(``0[],System.Action{``0},System.Func{``1,System.Boolean})">
            <summary>Выполнение действия для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="action">ВЫполняемое действие</param>
            <param name="ErrorHandler">Обработчик исключений</param>
            <exception cref="T:System.ApplicationException">Возникает в случае если в методе action возникшее исключение не было обработано</exception>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TException">Тип исключений</typeparam>
        </member>
        <member name="M:System.ArrayExtantions.Function``2(``0[],System.Func{``0,``1})">
            <summary>Определение значения функции для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="f">Вычисляемая функция</param>
            <typeparam name="TIn">Тип элементов массива области определения</typeparam>
            <typeparam name="TOut">Тип элементов массива области значения</typeparam>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.ArrayExtantions.Initialize``1(``0[],System.Func{System.Int32,``0})">
            <summary>
            Инициализация массива
            </summary>
            <typeparam name="TArray">Тип элементов масива</typeparam>
            <param name="array">Инициализированный масив</param>
            <param name="Initializer">МЕтод инициализации</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtantions.SwapCols``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>Поменять местами два столбца двумерного массива</summary>
            <param name="array">Двумерный массив</param>
            <param name="i">Номер первого столбца</param>
            <param name="j">Номер второго столбца</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtantions.CreateSequence(System.Int32,System.Int32)">
            <summary>Создать массив последовательных значений длины <paramref name="length"/> начиная с <paramref name="offset"/></summary>
            <param name="length">Длина массива</param>
            <param name="offset">НАчальное значение</param>
            <returns>Массив чисел длины <paramref name="length"/> начиная с <paramref name="offset"/></returns>
        </member>
        <member name="M:System.ArrayExtantions.Mix``1(``0[])">
            <summary>Создать копию массива с перемешанным содержимым</summary>
            <param name="array">Исходный массив</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Копия исходного массива с перемешанным созержимым</returns>
        </member>
        <member name="M:System.ArrayExtantions.MixRef``1(``0[])">
            <summary>Перемешать массив</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Перемешиваемый массив</param>
            <returns>Исходный массив с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtantions.SetSubArrays``1(``0[],``0[][])">
            <summary>Последовательно скопировать набор массивов в буффер</summary>
            <param name="A">Буфферный массив соответствующей длины</param>
            <param name="B">Перечень устанавливаемых значений</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="T:System.FuncExtentions">
            <summary>Класс методов-расширений для функции</summary>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_NewtonsMethod(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом Ньютона</summary>
            <param name="f">Исследуемая функция</param>
            <param name="df">Дифференциал исследуемой функции</param>
            <param name="x0">Начальное приближение</param>
            <param name="max_iterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_NewtonsMethodAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом Ньютона</summary>
            <param name="f">Исследуемая функция</param>
            <param name="df">Дифференциал исследуемой функции</param>
            <param name="x0">Начальное приближение</param>
            <param name="max_iterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_BisectionMethod(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary> Поиск нуля функции методом бисекции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="max_iterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.ArithmeticException"><paramref name="f" /> is equal to <see cref="F:System.Double.NaN" />. </exception>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_BisectionMethodAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary> Поиск нуля функции методом бисекции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="max_iterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.ArithmeticException"><paramref name="f" /> is equal to <see cref="F:System.Double.NaN" />. </exception>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_GoldenSection(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Золотого сечения</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_GoldenSectionAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Золотого сечения</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_TernarySearch(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Троичного деления</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_TernarySearchAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Троичного деления</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_FalsiPositionMethod(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом False position</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="max_iterations">Максимальное допустимое число итераций метода</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_FalsiPositionMethodAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом False position</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="max_iterations">Максимальное допустимое число итераций метода</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_MethodOfChords(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом хорд</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_MethodOfChordsAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом хорд</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.Carring``3(System.Func{``0,``1,``2})">
            <summary>Карирование функции двух параметров</summary>
            <typeparam name="TArg1">Тип значение первого параметра функции</typeparam>
            <typeparam name="TArg2">Тип значение второго параметра функции</typeparam>
            <typeparam name="TResult">Тип результата функции</typeparam>
            <param name="f">Карируемая функция</param>
            <returns>Функция одного переменного типа <typeparam name="TArg1"/></returns>
        </member>
        <member name="M:System.FuncExtentions.Func(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Функция от функци q(f(x))</summary>
            <param name="f">Внутренняя функция</param>
            <param name="q">Внешняя функция</param>
            <returns>ФУнкция q от функции f</returns>
        </member>
        <member name="M:System.FuncExtentions.FuncFor(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Функция от функции f(q(x))</summary>
            <param name="f">Внешняя функция</param>
            <param name="q">Внутренняя функция</param>
            <returns>Функция f от функции q</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">КОнечное значение интервала интегрирования</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValueAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">КОнечное значение интервала интегрирования</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_Simpson(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Численный расчёт определённого интеграла методом симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Число интервало интегрирования N > 2</param>
            <returns>Интеграл функции на отрезке метдом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_SimpsonAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Численный расчёт определённого интеграла методом симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Число интервало интегрирования N > 2</param>
            <returns>Интеграл функции на отрезке метдом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_Adaptive(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Численный расчёт определённого интеграла методом адаптивного разбиения</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Начальное разбиение отрезка</param>
            <param name="eps">Точность вычисления интеграла</param>
            <returns>Адаптивный интеграл функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_AdaptiveAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Численный расчёт определённого интеграла методом адаптивного разбиения</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Начальное разбиение отрезка</param>
            <param name="eps">Точность вычисления интеграла</param>
            <returns>Адаптивный интеграл функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_Spline(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Значение интеграла функции методом сплайнов</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начало отрезка интегрирования</param>
            <param name="x2">Конец отрезка интегрирования</param>
            <param name="N">Разбиение интервала интегрирования</param>
            <returns>Значение интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_SplineAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Значение интеграла функции методом сплайнов</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начало отрезка интегрирования</param>
            <param name="x2">Конец отрезка интегрирования</param>
            <param name="N">Разбиение интервала интегрирования</param>
            <returns>Значение интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtentions.Reverse(System.Func{System.Double,System.Double})">
            <summary>-f(x)</summary>
        </member>
        <member name="M:System.FuncExtentions.FuncCalculator`2.Calculate(System.Object)">
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetValuesParralel``2(System.Func{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>Вычислить значения функции параллельно</summary>
            <param name="f">Вычисляемая функция</param>
            <param name="Arguments">Область определения</param>
            <typeparam name="TArgument">Тип аргумента</typeparam>
            <typeparam name="TResult">Тип значения</typeparam>
            <returns>Массив значений функции</returns>
        </member>
        <member name="T:System.FuncExtentions.SamplingResult`1">
            <summary>Результат дескритезации функции</summary>
            <typeparam name="TValue">Тип значений функции</typeparam>
        </member>
        <member name="T:System.FuncExtentions.SamplingResult`1.Result">
            <summary>Отсчёт функции</summary>
        </member>
        <member name="F:System.FuncExtentions.SamplingResult`1.Result.Argument">
            <summary>Значение аргумента отсчёта</summary>
        </member>
        <member name="F:System.FuncExtentions.SamplingResult`1.Result.Value">
            <summary>Значение функции</summary>
        </member>
        <member name="M:System.FuncExtentions.SamplingResult`1.Result.#ctor(System.Double,`0)">
            <summary>Инициализация нового отсчёта функции</summary>
            <param name="Argument">Значение аргумента функции</param>
            <param name="Value">Значение функции</param>
        </member>
        <member name="M:System.FuncExtentions.SamplingResult`1.Result.op_Implicit(System.FuncExtentions.SamplingResult{`0}.Result)~System.Tuple{System.Double,`0}">
            <summary>Оператор неявного приведения отсчёта функции к картежу двух элементов - значение отсчёта функции - значение функции</summary>
            <param name="result">Отсчёт функции</param>
        </member>
        <member name="P:System.FuncExtentions.SamplingResult`1.Values">
            <summary>Перечисление отсчётов функции</summary>
        </member>
        <member name="P:System.FuncExtentions.SamplingResult`1.Accuracy">
            <summary>Оценка точности дискретизации</summary>
        </member>
        <member name="M:System.FuncExtentions.SamplingResult`1.#ctor(System.Collections.Generic.IEnumerable{System.FuncExtentions.SamplingResult{`0}.Result},System.Double)">
            <summary>Инициализация нового результата дискретизации функции</summary>
            <param name="Values">Перечисление отсчётов функции</param>
            <param name="Accuracy">Оценка точности дискретизации</param>
        </member>
        <member name="T:System.FuncExtentions.SimpleSamplingResult">
            <summary>Результат дискретизации вещественной функции</summary>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.Sampling(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
            <returns>Кортеж, содержащий связанный список дискретов функции и оценку точности дискретизации</returns>
        </member>
        <member name="F:System.FuncExtentions.SimpleSamplingResult.f_F">
            <summary>Дискретизируемая функция</summary>
        </member>
        <member name="F:System.FuncExtentions.SimpleSamplingResult.f_List">
            <summary>Связанный список отсчётов функции</summary>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.#ctor(System.Tuple{System.Collections.Generic.LinkedList{System.FuncExtentions.SamplingResult{System.Double}.Result},System.Double})">
            <summary>Инициализация нового результата дискретизации по кортежу дискретов функции и оценки точности дискретизации</summary>
            <param name="SamplingResult">Кортеж дискретов функции и оценки точности дскретизации</param>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового результата дискретизации</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.ClarifySampling(System.Double)">
            <summary>Уточнение результата дискретизации</summary>
            <param name="accuracy">Требуемая точность</param>
            <returns>Истина, если требуемая точность достигнута</returns>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.GetValues">
            <summary>Метод получения отсчётов функции</summary>
            <returns>Массив отсчётов функции</returns>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.op_Implicit(System.FuncExtentions.SimpleSamplingResult)~System.FuncExtentions.SamplingResult{System.Double}.Result[]">
            <summary>Оператор неявного приведения типа результата дискретизации к типу массива отсчётов функции</summary>
            <param name="result">Результат дискретизации</param>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Адаптивный метод дискретизации вещественной функции</summary>
            <param name="f">Дискретизируемая вещественная функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="eps">Точность дискретизации</param>
            <returns>Результат дискретизации вещественной функции</returns>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Адаптивный метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="eps">Точность дискретизации</param>
            <returns>Результат дискретизации функции</returns>
        </member>
        <member name="M:System.ByteExtentions.IsPowerOf2(System.Byte)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.ByteExtentions.BitCount(System.Byte)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.ByteExtentions.BitReversing(System.Byte,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит [ = 16 ]</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ByteExtentions.IsOdd(System.Byte)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.ByteExtentions.IsEven(System.Byte)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="T:System.DoubleExtentions">
            <summary>Расширения для чисел двойной точности</summary>
        </member>
        <member name="M:System.DoubleExtentions.Sqrt(System.Double)">
            <summary>Квадратный корень</summary>
            <param name="x">Число из которого извлекается квадратный корень</param>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:System.DoubleExtentions.IsInt(System.Double)">
            <summary>Является ли число целым?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число целое</returns>
        </member>
        <member name="M:System.DoubleExtentions.Round(System.Double,System.Int32)">
            <summary>Округление числа до указанного количества знаков после запятой </summary>
            <param name="x">Округляемое число</param>
            <param name="n">Количество знаков после запятой при n >= 0 и до запятой при n меньше 0</param>
            <returns>Число, округлённое до указанной точности</returns>
        </member>
        <member name="M:System.DoubleExtentions.RoundAdaptive(System.Double,System.Int32)">
            <summary>Адаптивное округление</summary>
            <param name="x">Округляемая величина</param>
            <param name="n">Количество значащих разрядов</param>
            <returns>Число с указанным количеством значащих разрядов</returns>
        </member>
        <member name="M:System.DoubleExtentions.GetInverse(System.Double)">
            <summary>Получить обратное число</summary>
            <param name="x">Инвертируемое число</param>
            <returns>Число, обратное к исходном</returns>
        </member>
        <member name="M:System.DoubleExtentions.GetAbsMod(System.Double,System.Double)">
            <summary>Число по модулю</summary>
            <param name="x">Исходное число</param>
            <param name="mod">Модуль</param>
            <returns>Число по модулю</returns>
        </member>
        <member name="M:System.DoubleExtentions.GetAbs(System.Double)">
            <summary>Модуль числа</summary>
            <param name="x">Действительное вещественное число</param>
            <returns>Модуль числа</returns>
        </member>
        <member name="M:System.DoubleExtentions.Power(System.Double,System.Int32)">
            <summary>Возведение в целую степень</summary>
            <param name="x">Действительное число</param>
            <param name="n">Целочисленный показатель степени</param>
            <returns>x^n</returns>
        </member>
        <member name="M:System.DoubleExtentions.Power(System.Double,System.Double)">
            <summary>Возведение числа в действительную степень</summary>
            <param name="x">ОСнование</param><param name="y">Действительный показатель степени</param>
            <returns>Действительное число x возведённое в степень y: x^y</returns>
        </member>
        <member name="M:System.DoubleExtentions.Power(System.Double,MathService.Complex)">
            <summary>Возведение числа в комплексную степень</summary>
            <param name="x">Основание</param><param name="z">Комплексный показатель степень</param>
            <returns>Значение x^z, где x - действительное, z - комплексное</returns>
        </member>
        <member name="M:System.DoubleExtentions.In_dB(System.Double)">
            <summary>Преобразование в децебеллы по амплитуде</summary>
            <param name="x">Амплитудное значение 20*lg(x)</param>
            <returns>Значение в децебеллах</returns>
        </member>
        <member name="M:System.DoubleExtentions.In_dB_byPower(System.Double)">
            <summary>Преобразование в децебеллы по мощности</summary>
            <param name="x">Значение мощности 10*lg(x)</param>
            <returns>Значение в децебеллах</returns>
        </member>
        <member name="M:System.DoubleExtentions.From_dB(System.Double)">
            <summary>Преобразование из децебеллов в разы по значению (амплитуде)</summary>
            <param name="db">Значение в децебеллах 10^(x/20)</param>
            <returns>Значение в разах по амплитуде</returns>
        </member>
        <member name="M:System.DoubleExtentions.From_dB_byPower(System.Double)">
            <summary>Преобразование из децебеллов в разы по мощности</summary>
            <param name="db">Значение в децебеллах 10^(x/10)</param>
            <returns>Значение в разах по мощности</returns>
        </member>
        <member name="M:System.DoubleExtentions.ToRad(System.Double)">
            <summary>Преобразование значения в радианы</summary>
            <param name="deg">Значение в градусах</param>
            <returns>Значение в радианах</returns>
        </member>
        <member name="M:System.DoubleExtentions.ToDeg(System.Double)">
            <summary>Преобразование значения в градусы</summary>
            <param name="rad">Значение в радианах</param>
            <returns>Значение в градусах</returns>
        </member>
        <member name="M:System.LongExtentions.IsPowerOf2(System.Int64)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.LongExtentions.BitCount(System.Int64)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.LongExtentions.BitReversing(System.Int64,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.LongExtentions.BitReversing(System.Int64)">
            <summary>Реверсирование всех 64 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.LongExtentions.IsOdd(System.Int64)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.LongExtentions.IsEven(System.Int64)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="M:System.ShortExtentions.IsPowerOf2(System.Int16)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.ShortExtentions.BitCount(System.Int16)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.ShortExtentions.BitReversing(System.Int16,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ShortExtentions.BitReversing(System.Int16)">
            <summary>Реверсирование всех 16 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ShortExtentions.IsOdd(System.Int16)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.ShortExtentions.IsEven(System.Int16)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="T:System.EventHandlerExtension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.EventHandler,System.Object,System.EventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.StartAsync(System.EventHandler,System.Object,System.EventArgs,System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart(System.EventHandler,System.Object)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart(System.EventHandler,System.Object,System.EventArgs)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart``1(System.EventHandler{``0},System.Object,``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start``1(System.EventHandler{``0},System.Object,``0)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.StartAsync``1(System.EventHandler{``0},System.Object,``0,System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхроная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start``3(System.EventHandler{``0,``1,``2},``1,``2)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Args">Аргументы события</param>
            <typeparam name="TResult">Тип результата обработки события</typeparam>
            <typeparam name="TSender">Тип источника события</typeparam>
            <returns>Массив результатов обработки события</returns>
        </member>
        <member name="M:System.ObjectExtentions.ConvertObjectTo``2(``0,System.Converter{``0,``1})">
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.ObjectExtentions.InitializeObject``1(``0,System.Action{``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="Initializator">Метод инициализации</param>
            <returns>Инициализированный объект</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.ObjectExtentions.InitializeObject``1(``0,System.Func{``0,``0})">
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.TypeExtentions.GetType(System.String)">
            <summary>Получить тип по его имени из всех загруженных сборок</summary>
            <param name="TypeName">Имя типа</param>
            <returns>Тип</returns>
        </member>
        <member name="T:System.IntExtentions">
            <summary>Класс методов-расширений для класса целых 4-х-байтовых чисел со знаком</summary>
        </member>
        <member name="M:System.IntExtentions.Power(System.Int32,System.Int32)">
            <summary>Возведение целого числа в целую степень</summary>
            <param name="x">Целое основание</param>
            <param name="N">Целый показатель степени</param>
            <returns>Результат возведения целого основания в целую степень</returns>
        </member>
        <member name="M:System.IntExtentions.Power(System.Int32,System.Double)">
            <summary>Возведение целого числа в вещественную степень</summary>
            <param name="x">Целое основание</param>
            <param name="q">Вещественный показатель степени</param>
            <returns>Результат возведения целого основания в вещественную степень</returns>
        </member>
        <member name="M:System.IntExtentions.Power(System.Int32,MathService.Complex)">
            <summary>Возведение целого числа в комплексную степень</summary>
            <param name="x">Целое основание</param>
            <param name="z">Комплексный показатель степени</param>
            <returns>Результат возведения целого основания в комплексную степень</returns>
        </member>
        <member name="M:System.IntExtentions.FactorizationEnum(System.Int32)">
            <summary>Факторизация целого числа</summary>
            <param name="n">Раскладываемое число</param>
            <returns>Последовательность простых чисел составляющих раскладываемое число</returns>
        </member>
        <member name="M:System.IntExtentions.FactorizationList(System.Int32)">
            <summary>Разложение числа на простые множетили</summary>
            <param name="n">Раскладываемое число</param>
            <returns>Массив простых множителей</returns>
        </member>
        <member name="M:System.IntExtentions.Factorization(System.Int32)">
            <summary>Разложение числа на простые множители</summary>
            <param name="n">Раскладываемое число</param>
            <returns>Словарь с делителями числа - значение элементов словаря - кратность делителя</returns>
        </member>
        <member name="M:System.IntExtentions.IsPrime(System.Int32)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="n">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.IntExtentions.IsPowerOf2(System.Int32)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="n">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.IntExtentions.BitCount(System.Int32)">
            <summary>Число бит числа</summary>
            <param name="n">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.IntExtentions.GetNumberOfDigits(System.Int32,System.Int32)">
            <summary>Получить число разрядов в указаной системе счисления</summary>
            <param name="n">Рассматриваемое число</param>
            <param name="Base">Основание системы счисления. По умолчанию = 10</param>
            <returns>Количество разрядов в указанной системе счисления</returns>
        </member>
        <member name="M:System.IntExtentions.GetBitArray(System.Int32,System.Int32)">
            <summary>Получить битовый массив из числа</summary>
            <param name="Value">Преобразуемое число</param>
            <param name="Length">Длина результирующего массива бит. По умолчанию = 32 битам</param>
            <returns>Битовый массив числа</returns>
        </member>
        <member name="M:System.IntExtentions.BitReversing(System.Int32,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.IntExtentions.BitReversing(System.Int32)">
            <summary>Реверсирование всех 32 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.IntExtentions.IsDevidedTo(System.Int32,System.Int32)">
            <summary>Проверка делимости числа на делитель</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Истина, если остаток от целочисленного деления равен 0</returns>
        </member>
        <member name="M:System.IntExtentions.GetAbsMod(System.Int32,System.Int32)">
            <summary>Положительный остаток от деления</summary>
            <param name="x">Делимое</param>
            <param name="mod">Модуль</param>
            <returns>Остаток от деления</returns>
        </member>
        <member name="M:System.IntExtentions.GetAbs(System.Int32)">
            <summary>Получить абсолютное значение числа</summary>
            <param name="x">Вещественное число</param>
            <returns>Модуль числа</returns>
        </member>
        <member name="M:System.IntExtentions.GetNOD(System.Int32,System.Int32)">
            <summary>Наибольший общий делитель</summary>
            <param name="Y">Первое число</param>
            <param name="X">Второе число</param>
            <returns>Наибольший общий делитель</returns>
        </member>
        <member name="M:System.IntExtentions.IsOdd(System.Int32)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.IntExtentions.IsEven(System.Int32)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="M:System.IntExtentions.Factorial(System.Int32)">
            <summary>Факториал целого числа >= 0 и значение Г-функции для отрицательных значений</summary>
            <param name="n">Исходное число</param>
            <returns>Факториал числа</returns>
        </member>
        <member name="M:System.IntExtentions.ToOctBase(System.Int32)">
            <summary>Приведение целого числа в 10 системе счисления к виду системы счисления по основанию 8</summary>
            <param name="n">Число в 10-ой системе счисления</param>
            <returns>Представление числа в 8-ричной системе счисления</returns>
        </member>
        <member name="M:System.IntExtentions.FromOctalBase(System.Int32)">
            <summary>Приведение целого числа в 8 системе счисления к виду системы счисления по основанию 10</summary>
            <param name="x">Число в 8-ой системе счисления</param>
            <returns>Представление числа в 10-ричной системе счисления</returns>
        </member>
        <member name="T:System.Cycle">
            <summary>Цыклы алгоритмы</summary>
        </member>
        <member name="M:System.Cycle.ForParallel(System.Action{System.Int32,System.Int32},System.Int32,System.Boolean)">
            <summary>Циклическое выполнение действия в параллельном режиме</summary>
            <param name="cycle">Выполняемое действие</param>
            <param name="N">Число повторений</param>
            <param name="Whait">Оиждать давершения цикла?</param>
        </member>
        <member name="M:System.Cycle.ForLinear(System.Action{System.Int32,System.Int32},System.Int32)">
            <summary>Циклическое выполнение действия в последовательном режиме</summary>
            <param name="cycle">Выполняемое действие</param><param name="N">Число повторений</param>
        </member>
        <member name="T:System.Reflection.Event`2">
            <summary>Событие</summary>
            <typeparam name="TObject">Тип объекта-источника события</typeparam>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
        </member>
        <member name="E:System.Reflection.Event`2.EventHandler">
            <summary>Событие</summary>
        </member>
        <member name="F:System.Reflection.Event`2.f_EventInfo">
            <summary>Описание события</summary>
        </member>
        <member name="F:System.Reflection.Event`2.f_Object">
            <summary>Объект-источник</summary>
        </member>
        <member name="M:System.Reflection.Event`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Событие</summary>
            <param name="o">Объект-источник события</param>
            <param name="Name">Название события</param>
            <param name="Private">Приватность описания события в классе объекта</param>
        </member>
        <member name="T:System.Reflection.Property`2">
            <summary>"Свойство" позднего связывания</summary>
            <typeparam name="TObject">Тип объекта, для которого определяется свойство</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
        </member>
        <member name="F:System.Reflection.Property`2.f_PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Reflection.Property`2.f_Name">
            <summary>Имя свйоства</summary>
        </member>
        <member name="F:System.Reflection.Property`2.f_Object">
            <summary>Объект, которому принадлежит свйоство</summary>
        </member>
        <member name="F:System.Reflection.Property`2.f_Private">
            <summary>Флаг приватности свйоства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.PropertyType">
            <summary>
            Тип значения свойства
            </summary>
        </member>
        <member name="P:System.Reflection.Property`2.Name">
            <summary>Имя свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Object">
            <summary>Объект, определяющий свойтсво</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Private">
            <summary>Признак - является ли свойство пиватным</summary>
        </member>
        <member name="P:System.Reflection.Property`2.IsExist">
            <summary>Признак </summary>
        </member>
        <member name="P:System.Reflection.Property`2.Value">
            <summary>Значение свйоства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.CanRead">
            <summary>Признак возможности читать значение</summary>
        </member>
        <member name="P:System.Reflection.Property`2.CanWrite">
            <summary>Признак возможности устанавливать значение</summary>
        </member>
        <member name="P:System.Reflection.Property`2.SupportsChangeEvents">
            <summary>
            Поддерживает генерацию событий изменения значения
            </summary>
        </member>
        <member name="P:System.Reflection.Property`2.Attributes">
            <summary>Атрибуты свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Descriptor">
            <summary>
            Дескриптор свйоства объекта
            </summary>
        </member>
        <member name="M:System.Reflection.Property`2.#ctor(System.String,System.Boolean)">
            <summary>Новый объект "Свойство" для позднего связывания</summary>
            <param name="Name">Имя свйосвта</param>
            <param name="Private">Является ли свойство скрытым</param>
        </member>
        <member name="M:System.Reflection.Property`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Новый объект "Свойство" для позднего связывания</summary>
            <param name="o">Объект, для которого определяется свойство</param>
            <param name="Name">Имя свйосвта</param>
            <param name="Private">Является ли свойство скрытым</param>
        </member>
        <member name="T:System.IEnumerableExtentions">
            <summary>Класс методов-расширений для интерфейса перечисления</summary>
        </member>
        <!-- Проигнорирован некорректный комментарий XML для члена "M:System.IEnumerableExtentions.WhereNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" -->
        <member name="M:System.IEnumerableExtentions.TakeWhileNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Возвращает цепочку элементов последовательности, удовлетворяющих указанному условию</summary>
            <returns>
            Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, содержащий элементы входной последовательности до первого элемента, который не прошел проверку.
            </returns>
            <param name="collection">Последовательность, из которой требуется возвратить элементы.</param>
            <param name="NotSelector">Функция для проверки каждого элемента на соответствие условию.</param>
            <typeparam name="T">Тип элементов последовательности <paramref name="collection"/>.</typeparam>
            <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="collection"/> или <paramref name="NotSelector"/> — null.</exception>
        </member>
        <member name="M:System.IEnumerableExtentions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Преобразование перечисления в массив с преобразованием элементов</summary>
            <typeparam name="T">Тип элементов исходного перечисления</typeparam>
            <typeparam name="Q">Тип элементов результирующего массива</typeparam>
            <param name="collection">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий массив, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на массив
            </returns>
        </member>
        <member name="M:System.IEnumerableExtentions.ToList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Преобразование перечисления в список с преобразованием элементов</summary>
            <typeparam name="T">Тип элементов исходного перечисления</typeparam>
            <typeparam name="Q">Тип элементов результирующего списка</typeparam>
            <param name="collection">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий список, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на список
            </returns>
        </member>
        <member name="M:System.IEnumerableExtentions.Aggregate(System.Collections.Generic.IEnumerable{System.String})">
            <summary>Объединение перечисления строк в единую строку с разделителем - переносом строки</summary>
            <param name="Lines">Перечисление строк</param>
            <returns>Если ссылка на перечисление пуста, то пустая ссылка на строку, иначе - объединение строк с разделителем - переносом строки</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Проверка перечисления на пустоту</summary>
            <param name="collection">Проверяемое перечисление</param>
            <typeparam name="T">Тип элемента перечисления</typeparam>
            <returns>Истина, если перечисление пусто</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,System.Int32,``1},System.Int32)">
            <summary>Объединить элементы коллеции</summary>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
            <param name="collection">Исходная коллекция элементов</param>
            <param name="Init">Исходное состояние результата объединения</param>
            <param name="func">Метод объединения</param>
            <param name="index">Индекс элемента коллекции</param>
            <returns>Результат объединения коллекции элементов</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Проверка на наличие элемиента в коллекции</summary>
            <typeparam name="T">Тип элемента</typeparam>
            <param name="collection">Проверяемая коллекция</param>
            <param name="selector">Метод выбора</param>
            <returns>Истина, если выполняется предикат хотя бы на одном элементе коллекции</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.Find``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Найти элемент в перечислении, удовлетворяющий предикату</summary>
            <param name="collection">Перечисление элементов</param>
            <param name="selector">Предикат выбора</param>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <returns>Найденный элемент, либо пустая ссылка</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
        </member>
        <member name="M:System.IEnumerableExtentions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента колеекции</param>
            <typeparam name="T">Тип элемента колекции</typeparam>
        </member>
        <member name="M:System.IEnumerableExtentions.CastLeazy``1(System.Collections.IEnumerable)">
            <returns>Коллекция объектов преобразованного типа</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.ForeachLeazy``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Отложенное выполнение указанного действия для каждого элемента колеекци</summary>
            <typeparam name="T">Тип элементов коллеции</typeparam>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Выполняемое действие</param>
            <returns>Коллекция элементов, для элементов которой выполняется отложенное действие</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.ForeachLeazy``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Int32)">
            <summary>Отложенное выполнение действия до перебора элементов колеекци</summary>
            <typeparam name="T">Тип элементов коллеции</typeparam>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Выполняемое действие</param>
            <param name="index">Начальный индекс элемента коллекции</param>
            <returns>Коллекция элементов, для элементов которой которой выполняется действие</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.Function``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Вычисление функции от всех элементов колеекции</summary>
            <param name="Collection">Коллекция значений аргумента вычисляемой функции</param>
            <param name="f">Вычисляемая функция</param>
            <typeparam name="T">Тип аргумента функции</typeparam>
            <typeparam name="TResult">Тип значения функции</typeparam>
            <returns>Коллекция значений функции на всей области определения</returns>
        </member>
        <member name="T:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2">
            <summary>Класс вычисления значений функции для коллекции аргументов</summary>
            <typeparam name="T">Тип аргумента функции</typeparam>
            <typeparam name="TResult">Тип значения функции</typeparam>
        </member>
        <member name="T:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.EnumirableCollectionFunctionCalculatorEnumirator">
            <summary>Перечислитель коллеции рассчитанных значений функции</summary>
        </member>
        <member name="F:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.EnumirableCollectionFunctionCalculatorEnumirator.f_Enumirator">
            <summary>Перечислитель коллекции аргументов функции</summary>
        </member>
        <member name="F:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.EnumirableCollectionFunctionCalculatorEnumirator.f_Function">
            <summary>Вычисляемая функция</summary>
        </member>
        <member name="P:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.EnumirableCollectionFunctionCalculatorEnumirator.Current">
            <summary>Текцущий элемент коллекции значений функции</summary>
        </member>
        <member name="P:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.EnumirableCollectionFunctionCalculatorEnumirator.System#Collections#IEnumerator#Current">
            <summary>Текцущий элемент коллекции значений функции</summary>
        </member>
        <member name="M:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.EnumirableCollectionFunctionCalculatorEnumirator.#ctor(System.Collections.Generic.IEnumerator{`0},System.Func{`0,`1})">
            <summary>Инициализация нового перечислителя колеекции рассчитанных значений функции</summary>
            <param name="Enumirator">Перечислитель коллекции аргументов области определения</param>
            <param name="f">Вычисляемая функция</param>
        </member>
        <member name="M:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.EnumirableCollectionFunctionCalculatorEnumirator.Dispose">
            <summary>Освобождение ресурсов</summary>
        </member>
        <member name="M:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.EnumirableCollectionFunctionCalculatorEnumirator.MoveNext">
            <summary>Переход к следующему элементу коллекции</summary>
            <returns>Истина, если переход выполнен успешно</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.EnumirableCollectionFunctionCalculatorEnumirator.Reset">
            <summary>Сброс состояния перечислителя</summary>
        </member>
        <member name="F:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.f_Collection">
            <summary>Коллекция аргументов функции</summary>
        </member>
        <member name="F:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.f_Function">
            <summary>Вычисляемая функция</summary>
        </member>
        <member name="M:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1})">
            <summary>Инициализация нового потокового вычислителя функции на коллекции аргументов</summary>
            <param name="Collection">Коллекция аргументов</param>
            <param name="f">Вычисляемая функция</param>
        </member>
        <member name="M:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.GetEnumerator">
            <summary>Получение перечислителя</summary>
            <returns>Перечислитель рассчитанных значений функции</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.EnumirableCollectionFunctionCalculator`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Неявное получение перечислителя</summary>
            <returns>Перечислитель расссчитанных значений функции</returns>
        </member>
        <member name="M:System.IEnumerableExtentions.Decimate``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>Проредить последовательность</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Прореживаемая последовательность</param>
            <param name="N">Размер выборки > 0</param>
            <param name="k">Положение в выборке (от 0 до N-1)</param>
            <returns>Последовательность из N-ых элементов выборки, стоящих на k-ом месте</returns>
        </member>
    </members>
</doc>
